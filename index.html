<!doctype html>
<html lang="ja">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no" />
    <!-- PWA: manifest + iOS/Android meta for standalone fullscreen from home screen -->
    <link rel="manifest" href="manifest.json" />
    <meta name="theme-color" content="#000000" />
    <meta name="mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />
    <meta name="apple-mobile-web-app-title" content="グルコースマンの落ちゲー" />
    <link rel="apple-touch-icon" href="assets/IMG_7890.PNG" sizes="180x180" />
    <link rel="icon" href="favicon.ico" />
    <title>グルコースマンの落ちゲー</title>
    <style>
      html, body {
        margin: 0;
        height: 100%;
        background: linear-gradient(#bfe1ff, #ffffff);
        color: #0f1a2a;
        font-family: system-ui, -apple-system, Segoe UI, Roboto, Noto Sans JP, Helvetica, Arial, sans-serif;
        user-select: none;
        -webkit-user-select: none;
        -webkit-touch-callout: none;
        -webkit-user-drag: none;
        -webkit-tap-highlight-color: transparent;
        overflow: hidden; /* ページスクロール無効化 */
        overscroll-behavior: contain; /* プルリフレッシュ抑止 */
      }
      #wrap { position: relative; height: 100%; }
      canvas { display: block; width: 100%; height: 100%; }
      canvas { touch-action: none; }
      /* タップUI最適化 */
      a, button, .btn, .btnc { touch-action: manipulation; }
      img { -webkit-user-drag: none; }
      .hud {
        position: absolute; left: 8px; top: 8px;
        background: transparent;
        padding: 2px 4px; border-radius: 4px; font-weight: 600;
        box-shadow: none;
        color: #ffffff;
        transition: color 0.8s ease;
        opacity: 0.6;
        font-size: 10px;
        line-height: 1.2;
      }
      .center {
        position: absolute; inset: 0; display: flex; align-items: center; justify-content: center;
        /* Chromeで開始ボタンが効かない対策：パネルを操作可能に */
        pointer-events: auto;
      }
      .panel {
        pointer-events: auto;
        background: rgba(20,24,40,0.9);
        border: 1px solid rgba(255,255,255,0.08);
        border-radius: 12px; padding: 18px 22px; text-align: center;
        max-width: 520px; box-shadow: 0 12px 40px rgba(0,0,0,0.35);
        color: #e7f0ff;
        z-index: 10000; /* 常に前面 */
      }
      .title { font-size: 40px; font-weight: 800; margin-bottom: 10px; }
      .subtitle { font-size: 32px; opacity: 0.95; margin-bottom: 18px; }
      .key { display: inline-block; padding: 8px 20px; border-radius: 8px; background: #222846; margin: 0 4px; border: 1px solid rgba(255,255,255,0.1); font-size: 28px; }
      .btn { display: inline-block; margin-top: 16px; padding: 16px 24px; border-radius: 10px; background: #5161ff; color: white; font-weight: 700; cursor: pointer; font-size: 32px; }
      .btn:active { transform: translateY(1px); }
      .small { font-size: 28px; opacity: 0.9; }
      /* HUDは左上に小さく半透明で表示 */
      .hud { font-size: 10px; }
      a { color: #a8b4ff; text-decoration: none; }

      /* モバイル操作ボタン */
      .touch { position: absolute; inset: 0; pointer-events: none; }
      .pad { position: absolute; bottom: calc(10px + env(safe-area-inset-bottom)); pointer-events: auto; display: flex; gap: 14px; align-items: center; }
      .pad.left { left: 12px; }
      .pad.right { right: 12px; }
      .pad .btnc {
        width: 64px; height: 64px; min-width: 48px; min-height: 48px; border-radius: 50%;
        background: rgba(81,97,255,0.22);
        border: 1px solid rgba(255,255,255,0.15);
        box-shadow: 0 6px 18px rgba(0,0,0,0.35);
        color: #e7f0ff; font-weight: 800; font-size: 36px;
        display: flex; align-items: center; justify-content: center;
        user-select: none; -webkit-user-select: none;
        backdrop-filter: blur(2px);
      }
      .pad .btnc:active { transform: translateY(1px); filter: brightness(1.15); }
      /* リスタートボタンは最前面・タップ可能 */
      #restartBtn { position: relative; z-index: 9999; pointer-events: auto; touch-action: manipulation; }
      /* 右上フェーズ名バッジは非表示 */
      .phase-badge { display: none !important; }
      @media (min-width: 480px) {
        .pad .btnc { width: 82px; height: 82px; font-size: 44px; }
      }
    </style>
  </head>
  <body>
    <div id="wrap">
      <canvas id="game"></canvas>
      <div class="hud" id="hud">フェーズ: 現世のうつしよ ― 光の回廊 ／ スコア: 0</div>
      <!-- 音量トグルは内部機能として保持（画面には表示しない） -->
      <div class="hud" id="sfxBtn" style="display:none;">SFX: ON</div>
      <div class="hud" id="bgmBtn" style="display:none;">BGM: ON</div>
      <audio id="bgm" src="assets/ン.mp3" preload="none" loop></audio>
      
      <!-- タッチ操作エリア（スマホ） -->
      <div class="touch" id="touch">
        <div class="pad left">
          <div class="btnc" id="btnLeft">←</div>
          <div class="btnc" id="btnJumpL">⤴︎</div>
        </div>
        <div class="pad right">
          <div class="btnc" id="btnJumpR">⤴︎</div>
          <div class="btnc" id="btnRight">→</div>
        </div>
      </div>
      <div class="center" id="overlay">
        <div class="panel" id="panel">
          <div class="title">グルコースマンの落ちゲー</div>
          <div class="subtitle">下から上へせり上がる足場を乗り継ぎながら、できるだけ下へ降り続けよう！</div>
          <div>操作: <span class="key">←</span> <span class="key">→</span> または <span class="key">A</span> <span class="key">D</span> ／ ジャンプ: <span class="key">↑</span> <span class="key">W</span> <span class="key">Space</span></div>
          <div class="small">スマホ: 画面下の ← ⤴︎ → ボタン</div>
          <div class="small">落ち続けて距離を稼ぎ、足場を踏み外して画面下に落ちるとゲームオーバー</div>
          <div class="small" id="bestLine" style="margin-top:8px"></div>
          <div class="btn" id="startBtn">ゲーム開始 (Enter/Space)</div>
        </div>
      </div>
    </div>

    <script>
      (() => {
        // iOSピンチ・ズーム/ジェスチャメニュー抑止
        window.addEventListener('gesturestart', (e) => e.preventDefault());
        window.addEventListener('gesturechange', (e) => e.preventDefault());
        window.addEventListener('gestureend', (e) => e.preventDefault());
        // ゲーム領域のタッチ既定動作を抑止（スクロール/ズーム防止）
        const wrapEl = document.getElementById('wrap');
        const gameEl = document.getElementById('game');
        const touchEl = document.getElementById('touch');
        const stop = (ev) => {
          // UIパネル(#panel)内の操作は除外して既定動作を許可
          try { if (ev.target && ev.target.closest && ev.target.closest('#panel')) return; } catch(_){}
          try { ev.preventDefault(); } catch(_){}
        };
        ['touchstart','touchmove','touchend','touchcancel'].forEach(t => {
          if (wrapEl) wrapEl.addEventListener(t, stop, { passive: false });
          if (gameEl) gameEl.addEventListener(t, stop, { passive: false });
          if (touchEl) touchEl.addEventListener(t, stop, { passive: false });
        });
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const hud = document.getElementById('hud');
        const overlay = document.getElementById('overlay');
        const startBtn = document.getElementById('startBtn');
        // DEVオプション（?dev=1|2 & phase=1|2|3|4）
        // window.DEV にも公開（本番挙動には影響なし）
        const DEV = (() => {
          try {
            const sp = new URL(location.href).searchParams;
            const devParam = (sp.get('dev') || '').trim();
            const enabled = devParam === '1' || devParam === '2';
            let phase = sp.get('phase');
            if (phase === '4') phase = 'final';
            if (phase !== '1' && phase !== '2' && phase !== '3' && phase !== 'final') phase = null;
            if (phase === '1') phase = 'phase1';
            if (phase === '2') phase = 'phase2';
            if (phase === '3') phase = 'phase3';
            const obj = { enabled, dev: enabled, phase };
            try { window.DEV = obj; } catch(_){}
            console.log('[DEV]', { devParam, DEV: obj });
            return obj;
          } catch (_) {
            try { window.DEV = { enabled: false, dev: false, phase: null }; } catch(_){}
            return { enabled: false, dev: false, phase: null };
          }
        })();

        const state = {
          running: false,
          gameOver: false,
          paused: false,
          score: 0, // platforms landed
          depth: 0, // meters (continuous)
          best: Number(localStorage.getItem('glucoseman_best') || 0),
          time: 0,
          sugars: 0,
          comboCount: 0,
          comboMult: 1,
          comboTime: 0,
          comboWindow: 2.2,
          fever: false,
          feverTime: 0,
          feverNeed: 5,
          pickStreak: 0,
          // セーフ足場関連
          safePlatformId: null,
          leftSafe: false,
          safeFadeT: 0,
          safeFading: false,
          // アクティブ化とスコア制御
          activated: false,
          lastScorePid: null,
          // 直前に立っていた足場（連続立ち用リセット）
          lastGroundId: null,
          // 観賞モードしきい値（無効化）
          passiveEndDepth: 999999,
          safeFadeDuration: 1.2,
          safeGlow: null,
          // 一度スコア加算した足場IDの集合（再着地での多重加点防止）
          scoredPids: new Set(),
          // 初着地グレース（開始/続き直後のすり抜け防止）
          allowFirstLand: false,
          firstLandingTimer: 0,
          firstLandingWait: false,
        };

        // デザイン係数（参考画像に合わせやすく）
        const design = {
          headRatio: 0.38,      // 頭半径 / 体全高（胴体を少し長く）
          eyeRadiusRatio: 0.30, // 目半径 / 頭半径
          eyeOffsetXR: 0.34,    // 目の左右オフセット / 頭半径
          shirtRatio: 0.60,     // 上半身の高さ比（胴体内）
        };

        // カラーパレット（グルコースマン用）初期値
        const palette = {
          head: '#9b59b6',
          headShade: '#8e44ad',
          leaf: '#35d07f',
          leafDark: '#26a767',
          // 服色（上=明るめ、下=暗め）参考画像から後で上書き
          shirtGreen: '#32c275',
          shirtGreenDark: '#23965a',
          pantsNavy: '#1e2a5a',
          pantsNavyDark: '#172045',
          suitYellow: '#ffd94d',
          eyeWhite: '#ffffff',
          eyeIris: '#2b2b2b',
          eyeShine: 'rgba(255,255,255,0.8)'
        };

        // 参考画像から色抽出（簡易）：上半身=明るめ、下半身=暗め
        function derivePaletteFromRef() {
          if (!refReady) return;
          const can = document.createElement('canvas');
          const W = 80, H = 80;
          can.width = W; can.height = H;
          const c = can.getContext('2d');
          c.drawImage(refImg, 0, 0, W, H);
          const img = c.getImageData(0, 0, W, H).data;
          const bins = new Map();
          for (let y = 0; y < H; y += 2) {
            for (let x = 0; x < W; x += 2) {
              const i = (y * W + x) * 4;
              const r = img[i], g = img[i+1], b = img[i+2], a = img[i+3];
              if (a < 128) continue;
              // 非常に白/黒に寄る色は除外
              const bright = (r+g+b)/3;
              if (bright > 245 || bright < 15) continue;
              // 4bit量子化
              const rq = r>>4, gq = g>>4, bq = b>>4;
              const key = (rq<<8)|(gq<<4)|bq;
              bins.set(key, (bins.get(key)||0)+1);
            }
          }
          const entries = [...bins.entries()].sort((a,b)=>b[1]-a[1]);
          if (!entries.length) return;
          // 上=明るめ、下=暗めの代表色を選択
          function keyToRgb(k){ return [(k>>8)&0xF, (k>>4)&0xF, k&0xF].map(v=>v*17); }
          function rgbToHex([r,g,b]){ return '#'+[r,g,b].map(v=>v.toString(16).padStart(2,'0')).join(''); }
          function darken([r,g,b], f){ return [Math.max(0,Math.round(r*f)), Math.max(0,Math.round(g*f)), Math.max(0,Math.round(b*f))]; }
          let brightColor = null, darkColor = null;
          for (const [k,_cnt] of entries) {
            const rgb = keyToRgb(k);
            const br = (rgb[0]+rgb[1]+rgb[2])/3;
            if (!brightColor && br >= 80) { brightColor = rgb; }
            if (!darkColor && br <= 120) { darkColor = rgb; }
            if (brightColor && darkColor) break;
          }
          if (brightColor) {
            palette.shirtGreen = rgbToHex(brightColor);
            palette.shirtGreenDark = rgbToHex(darken(brightColor, 0.78));
          }
          if (darkColor) {
            palette.pantsNavy = rgbToHex(darkColor);
            palette.pantsNavyDark = rgbToHex(darken(darkColor, 0.78));
          }
        }

        // アニメ用パラメータ
        const anim = {
          squash: 1, // 1=通常 <1=縦伸び >1=縦つぶれ
          tilt: 0,   // 回転（ラジアン）
          leafPhase: 0,
          jumpKick: 0,
          landKick: 0,
          air: 0,   // 0=地上 1=空中
          // 2段ジャンプ用スピン
          spin: 0,
          spinVel: 0,
          spinTime: 0,
        };

        // 背景演出用テキスト（CLIと同趣旨の軽量版）
        const NEWS_TICKER = [
          '速報：XJ99%増加','株価###急落','TRND/NEW::不可解','NEWS ERR-404','警戒: ΔΔΔΔΔ','更新//STREAM','流行中::???','情報漏洩?','BREAK!!＞＞0xFF','指標: N/A%*rev','AI推定>>>未確定','臨時: proto-v1.9','市場: ███ 調整','規制案: draft-α','データ: 2025-??-??','緊急: ???/!!!','LIVE: feed失','解析: ghost値','トレンド: #NULL','速報：XXX-2049','注目: alt▲▼','速報: ping…lost','更新: meta//partial','偏差: σ=?','指数: –––','推移: ////','改訂: rev-b','予報: ???→???','注意: noise高','採点: NaN/100'
        ];
        
        const PHASE2_NEWS = [
          '速報：夢のジャングルにて"揺らぎの鼓動"を観測','現地リポート：森全体が脈動し、鼓動が大地を揺らす','Breaking Dream News：プレイヤーが未知の揺らぎに包まれる','夢世界調査局：第二フェーズ"揺らぎの鼓動"に突入','特報：鼓動の揺らぎが拡大、夢の奥地で異常事態を確認','緊急：揺らぎパターンの解析結果、予想を上回る複雑さ','現地映像：鼓動に合わせて光る植物群を発見','速報：揺らぎの鼓動が生物に与える影響を調査中','Breaking：夢ジャングルの奥深くから謎の音波を検出','特別レポート：揺らぎの鼓動、プレイヤーの心拍と同調か','緊急事態：鼓動の揺らぎが周辺エリアに拡散中','現場取材：揺らぎに包まれた生命体の生態変化を確認','速報：第二フェーズ突入により、夢世界に新たな現象','Breaking Dream Alert：揺らぎの鼓動、未知の周波数を記録'
        ];
        
        // フェーズ3用：新しいワード（フェーズ1と同様にランダムに浮遊）
        const PHASE3_FLOAT_WORDS = [
          'デジタルワールド','無意識の創造','夢は集合意識のブロックチェーン？','夢はAI生成と酷似',
          '眠りの中でまた眠る','多層夢を操る','ドリームチェーン','無意識クラウド',
          'ネストドリーム','メタスリープ','集合夢界','アルゴリズム幻','イマジネーション・ブロック',
          '潜在意識サーバー','多層幻界','ドリームエンジン',
          // 追加ワード
          '意識はファンタジー','思考は迷宮','誰かの夢の中？','まだ眠れる？','夢も現実も 何を魅せられている？'
        ];
        // フェーズ2用：新しい浮遊ワードのみを使用
        const PHASE2_FLOAT_WORDS = [
          '明晰夢','正夢','予知夢','白昼夢','悪夢','金縛り','幽体離脱','夢解釈','夢日記','潜在意識の声',
          '夢は妄想の世界','臨死体験','アストラル体験','前世の夢','集合夢','シンクロニシティ','覚醒夢'
        ];
        const POPUP_WORDS = [
          '速報','緊急','拡散>>>','データ更新','注目','警戒','LIVE','解析中','未確認','推定','流行中!?','影響度***','仮説','誤報?','続報','draft','β版','ghost','noise','mirror','NULL','TBD','fog'
        ];
        function shuffle(a){ const arr = a.slice(); for(let i=arr.length-1;i>0;i--){ const j=(Math.random()*(i+1))|0; [arr[i],arr[j]]=[arr[j],arr[i]];} return arr; }
        const BG = {
          tickerText: '', tickerX: 0, tickerSpeed: 60,
          popups: [], spawnTimer: 0,
          // フェーズ別ワードのシャッフル隊列
          wordOrder: { phase1: [], phase2: [], phase3: [] },
          wordIdx:   { phase1: 0,  phase2: 0,  phase3: 0  },
          // 旧フェーズ3囁きシステム（無効化）
          whisperActive: false, whisperText: '', whisperAlpha: 0, whisperTimer: 0, whisperIndex: 0, whisperTexts: [],
          // フェーズ2ニュース番組風テロップ（不使用）
          p2Active: false, p2Messages: [], p2Index: 0, p2X: 0, p2Speed: 90, p2Gap: 40,
          // 旧フェーズ3ポップアップ・中央固定テキスト（無効化）
          p3Active: false, p3Items: [], p3SpawnTimer: 0,
          p3CenterActive: false, p3CenterText: '', p3CenterTimer: 0, p3Cycle: 4.0,
        };

        function wordListForPhase(name){
          if (name === 'phase2') return PHASE2_FLOAT_WORDS;
          if (name === 'phase3') return PHASE3_FLOAT_WORDS;
          return POPUP_WORDS; // phase1 他
        }
        function resetWordQueue(name){
          try {
            const list = wordListForPhase(name) || [];
            BG.wordOrder[name] = shuffle(list);
            BG.wordIdx[name] = 0;
          } catch(_){}
        }
        function nextWordForPhase(name){
          if (!BG.wordOrder[name] || BG.wordIdx[name] >= BG.wordOrder[name].length) {
            resetWordQueue(name);
          }
          const idx = BG.wordIdx[name]++;
          const arr = BG.wordOrder[name] || [];
          return arr[idx % Math.max(1, arr.length)] || '';
        }

        // フェーズ専用リソース管理（特にphase1のDOM/タイマー/リスナを確実に破棄）
        const PhaseCleanup = {
          phase1: { timers: new Set(), rafs: new Set(), listeners: [] },
          addTimer(id) { this.phase1.timers.add(id); return id; },
          addRaf(id) { this.phase1.rafs.add(id); return id; },
          addListener(target, type, handler, opts) {
            this.phase1.listeners.push({ target, type, handler, opts });
            target.addEventListener(type, handler, opts);
          },
          clearPhase1() {
            // タイマー停止
            this.phase1.timers.forEach(id => { try { clearTimeout(id); clearInterval(id); } catch(_){} });
            this.phase1.timers.clear();
            // rAF停止（phase1専用で登録されたもののみ）
            this.phase1.rafs.forEach(id => { try { cancelAnimationFrame(id); } catch(_){} });
            this.phase1.rafs.clear();
            // リスナ解除
            for (const l of this.phase1.listeners) {
              try { l.target.removeEventListener(l.type, l.handler, l.opts); } catch(_){}
            }
            this.phase1.listeners.length = 0;
            // DOMノード除去（phase1専用としてマークされた要素）
            const nodes = document.querySelectorAll('.phase1-dom, [data-phase="1"]');
            nodes.forEach(n => { try { n.remove(); } catch(_){} });
            // CSSクラス除去（phase1-*）
            try {
              document.querySelectorAll('*').forEach(el => {
                if (!el.classList) return;
                [...el.classList].forEach(c => { if (c.startsWith('phase1-')) el.classList.remove(c); });
                // CSSアニメーション停止（phase1系に限るため data-phase="1" にも適用）
                if (el.matches('.phase1-dom, [data-phase="1"]')) {
                  el.style.animation = 'none';
                  el.style.transition = 'none';
                }
              });
            } catch(_){}
            // キャンバス側のフェーズ1描画状態も即時リセット
            BG.tickerText = '';
            BG.tickerX = 0;
          }
        };
        function initBG(phase = 'phase1'){
          // 囁きシステムをリセット
          BG.whisperActive = false;
          BG.whisperAlpha = 0;
          // フェーズ2テロップのリセット
          BG.p2Active = false;
          BG.p2Messages = [];
          BG.p2Index = 0;
          BG.p2X = 0;
          
          if (phase === 'phase3') {
            // フェーズ3：フェーズ1と同じ浮遊テキスト方式（新ワード）
            BG.popups = [];
            BG.spawnTimer = 0.6;
            BG.p3Active = false; BG.p3Items = [];
            BG.p3CenterActive = false; BG.p3CenterText = ''; BG.p3CenterTimer = 0;
            resetWordQueue('phase3');
          } else if (phase === 'phase2') {
            // フェーズ2：フェーズ1と同じ浮遊テキスト方式（新ワード）
            BG.p2Active = false;
            BG.p2Messages = []; BG.p2Index = 0; BG.p2X = 0;
            BG.popups = [];
            BG.spawnTimer = 0.6;
            resetWordQueue('phase2');
          } else {
            // その他のフェーズ：通常のティッカー
            let sourceArray = NEWS_TICKER;
            if (phase === 'phase2') {
              sourceArray = PHASE2_NEWS;
            }
            const items = shuffle(sourceArray).slice(0, 18);
            BG.tickerText = items.join('  |  ') + '   ';
            BG.tickerX = 0;
            resetWordQueue('phase1');
          }
          BG.spawnTimer = 0;
        }

        // 簡易サウンド（WebAudio）
        // === フェーズ制御システム ===
        const PHASES = [
          { name: 'phase1', start: 0 },       // 〜 349.999s
          { name: 'phase2', start: 350 },     // 5:50〜
          { name: 'phase3', start: 630 },     // 10:30〜 に変更
          { name: 'final',  start: 955 }      // 15:55〜
        ];

        const DIFFICULTY = {
          phase1: { 
            scrollSpeedMult: 1.0, 
            platformSpeedGain: 0.006,
            platformGapScale: 1.0, 
            sugarRate: 0.32,
            bgTint: 'rgba(0,0,0,0.0)',
            hudColor: '#ffffff'
          },
          phase2: { 
            scrollSpeedMult: 1.2, 
            platformSpeedGain: 0.008,
            // 後半フェーズは縦間隔を広げる（約 100〜150 相当）
            platformGapScale: 1.25, 
            sugarRate: 0.35,
            bgTint: 'rgba(0,0,64,0.08)',
            hudColor: '#b4c3ff'
          },
          phase3: { 
            scrollSpeedMult: 1.4, 
            platformSpeedGain: 0.010,
            // 後半フェーズは縦間隔を広げる（約 100〜150 相当）
            platformGapScale: 1.25, 
            sugarRate: 0.38,
            bgTint: 'rgba(64,0,0,0.10)',
            hudColor: '#ffc3b4'
          },
          final: { 
            scrollSpeedMult: 1.6, 
            platformSpeedGain: 0.012,
            // 最終フェーズも広めを維持
            platformGapScale: 1.25, 
            sugarRate: 0.42,
            bgTint: 'rgba(0,0,0,0.15)',
            hudColor: '#ffb4d4'
          },
        };

        let currentPhase = 'phase1';
        let phaseTransition = { active: false, timer: 0, duration: 2.0 };
        let screenShake = { active: false, intensity: 0, timer: 0, duration: 0 };
        // フェーズ3専用：スローモーション制御（0.5x → 1.0x）
        const timeCtl = { active: false, from: 1.0, target: 1.0, factor: 1.0, t: 0, duration: 0 };

        // フェーズごとの極端な難易度カーブ（スピード係数）
        const speedCtl = { base: 60, factor: 1.0 };
        // フェーズごとの速度変動（平均1.0、±率内に収める）
        // 速度変動（最終フェーズ後半のみ波打ち）
        const FINAL_WAVE_AMP = 0.12; // ±12% 程度
        const speedOsc = {
          t: 0,
          mod: 1,
          raw: 1,
          nextSpike: 0,
          spike: { active: false, t: 0, dur: 0, str: 0.0, sign: 1 }
        };
        function phasePeriod(name){ return 5.0; }
        function scheduleNextSpike(){ /* no-op (spike未使用) */ }
        let phaseTimer = 0; // 現フェーズ経過秒
        let phaseLenSec = 60; // 現フェーズ想定長（秒）
        let phaseSpeedProfile = { start: 1.0, mid: null, end: 1.5, split: 0.5 }; // フェーズの開始/中盤/終了係数、splitは前半割合
        function easeInOut(t){ return t*t*(3-2*t); }
        function clamp01(x){ return Math.max(0, Math.min(1, x)); }
        function lerp(a,b,t){ return a + (b-a) * t; }
        function phaseDurationFor(name){
          const idx = (name === 'final') ? 3 : (name === 'phase3' ? 2 : (name === 'phase2' ? 1 : 0));
          const start = PHASES[idx].start;
          const next = (idx+1 < PHASES.length) ? PHASES[idx+1].start : (PHASES[idx].start + 300);
          return Math.max(1, next - start);
        }

        function resolvePhase(t) {
          if (t >= PHASES[3].start) return 'final';
          if (t >= PHASES[2].start) return 'phase3';
          if (t >= PHASES[1].start) return 'phase2';
          return 'phase1';
        }
        // 外部ツールから参照できるように公開
        try {
          window.PHASES = PHASES;
          window.resolvePhase = resolvePhase;
        } catch(_) {}

        // === 背景用サブフェーズ（7ステップ） ===
        // ゲームロジックのフェーズとは独立して、BGM時間だけで背景切替を制御する
        const BG_STEPS = [
          { start: 0,     phase: 'phase1', sub: 1, step: 1 },     // 0–340
          { start: 340,   phase: 'phase2', sub: 1, step: 2 },     // 340–620
          { start: 620,   phase: 'phase3', sub: 1, step: 3 },     // 620–833
          { start: 833,   phase: 'phase3', sub: 2, step: 4 },     // 833–942
          { start: 942,   phase: 'final',  sub: 1, step: 5 },     // 942–1017
          { start: 1017,  phase: 'final',  sub: 2, step: 6 },     // 1017–1060
          { start: 1060,  phase: 'final',  sub: 3, step: 7 },     // 1060–END
        ];

        // 明示的な時間→背景インデックス関数（境界厳密）
        function getBgIndex(t) {
          const sec = Math.max(0, Number(t) || 0);
          // 新境界（秒）: 0–340, 340–620, 620–833, 833–955, 955–1017, 1017–1060, 1060–end
          if (sec < 340) return 0;           // 0–339.999
          else if (sec < 620) return 1;      // 340–620
          else if (sec < 833) return 2;      // 620–833
          else if (sec < 955) return 3;      // 833–954.999
          else if (sec < 1017) return 4;     // 955–1016.999
          else if (sec < 1060) return 5;     // 1017–1060
          else return 6;                     // 1060–end
        }
        try { window.getBgIndex = getBgIndex; } catch(_) {}
        // dev用テスト: test(0,340,620,833,942,1017,1060) → [0,1,2,3,4,5,6]
        try { window.test = (...vals) => { const out = vals.map(v=>getBgIndex(v)); console.log('[BG test]', out); return out; }; } catch(_) {}
        // 例: test(0,340,620,833,955,1017,1060) → [0,1,2,3,4,5,6]

        const bgVisual = {
          phase: 'phase1', sub: 1, step: 1,
          trans: { active: false, t: 0, dur: 1.0, fade: 0.3, from: { phase: 'phase1', sub: 1, step: 1 }, to: { phase: 'phase1', sub: 1, step: 1 } }
        };
        // 簡易パフォーマンス計測（FPSに応じてblur縮小/無効化）
        const PERF = { blurScale: 1, frames: 0, time: 0, evalT: 0 };

        function updateBgVisual(dt) {
          // 進行中は再入禁止（二重トリガ防止）
          if (bgVisual.trans.active) {
            bgVisual.trans.t += dt;
            if (bgVisual.trans.t >= bgVisual.trans.dur) {
              bgVisual.trans.active = false;
              try { if (DEV && DEV.dev) console.log('[BG] transition end'); } catch(_){}
            }
            return;
          }
          // BGM時間から背景インデックスを決定（getBgIndex のみ使用）
          const t = (bgmEl && isFinite(bgmEl.currentTime||NaN)) ? (bgmEl.currentTime||0) : (state.time||0);
          const idx = getBgIndex(t);
          const targetStep = (idx|0) + 1; // 1..7
          if (targetStep !== bgVisual.step) {
            // Safari等での時間ジャンプでも順番を必ず 1つずつ進める
            const nextStep = (targetStep > bgVisual.step) ? (bgVisual.step + 1) : targetStep;
            // 例外: 955s（step=5）への切替はハードカット（時刻が955s以上のときのみ）
            const isHardCut = (nextStep === 5) && (t >= 955.0);
            if (isHardCut) {
              bgVisual.trans.active = false;
              bgVisual.trans.t = 0;
              // ログ（dev）: mode:cut
              try {
                if (DEV && DEV.dev) {
                  const oldIdx = (bgVisual.step|0) - 1;
                  const newIdx = nextStep - 1;
                  const file = (BACKGROUNDS[newIdx]||'').split('/').pop();
                  console.log(`[BG] t=${t.toFixed(3)} idx ${Math.max(-1,oldIdx)}->${newIdx} (mode:cut) file: ${file}`);
                }
              } catch(_){}
              // 即時反映
              bgVisual.step = nextStep;
            } else {
              // 通常：スクロール切替
              bgVisual.trans.active = true;
              bgVisual.trans.t = 0;
              bgVisual.trans.dur = 10.0; bgVisual.trans.fade = 0.0;
              bgVisual.trans.from = { phase: bgVisual.phase, sub: bgVisual.sub, step: bgVisual.step };
              bgVisual.trans.to   = { phase: bgVisual.phase, sub: bgVisual.sub, step: nextStep };
              try {
                if (DEV && DEV.dev) {
                  const oldIdx = (bgVisual.trans.from.step|0) - 1;
                  const newIdx = nextStep - 1;
                  const file = (BACKGROUNDS[newIdx]||'').split('/').pop();
                  console.log(`[BG] t=${t.toFixed(3)} idx ${oldIdx}->${newIdx} (mode:scroll) file: ${file}`);
                }
              } catch(_){}
              // 目標状態に更新（描画はトランジションで段階的）
              bgVisual.step = nextStep;
            }
          }
          if (bgVisual.trans.active) {
            bgVisual.trans.t += dt;
            if (bgVisual.trans.t >= bgVisual.trans.dur) {
              bgVisual.trans.active = false;
            }
          }
        }

        // 即時フェーズ適用（BGM状態に依存しない）
        function applyPhaseImmediate(name){
          try {
            const prev = currentPhase;
            currentPhase = name;
            applyDifficulty(DIFFICULTY[name] || DIFFICULTY.phase1);
            if (typeof applyPhasePlayerTuning === 'function') applyPhasePlayerTuning(name);
            // 背景/囁き等をリセット
            BG.tickerText = ''; BG.tickerX = 0; BG.spawnTimer = 0;
            BG.whisperActive = false; BG.whisperText = ''; BG.whisperAlpha = 0; BG.whisperTimer = 0;
            BG.p2Active = false; BG.p2Messages = []; BG.p2Index = 0; BG.p2X = 0;
            BG.p3Active = false; BG.p3Items = []; BG.p3SpawnTimer = 0;
            // フェーズ1からの離脱時のクリーンアップ
            if (prev === 'phase1' && name !== 'phase1') { try { PhaseCleanup.clearPhase1(); } catch(_){} }
            initBG(name);
            // タイマ類
            phaseTimer = 0; phaseLenSec = phaseDurationFor(currentPhase);
          } catch(_){}
        }

        // DEV: フェーズジャンプ（G/H/J/K）。本編には影響しない開発用。
        async function jumpToPhase(n) {
          try {
            const idx = Math.max(1, Math.min(4, n)) - 1;
            const names = ['phase1', 'phase2', 'phase3', 'final'];
            const name = names[idx];
            // DEV強制フラグを更新（updatePhaseでの強制にも使う）
            try { DEV.phase = name; window.DEV && (window.DEV.phase = name); } catch(_){}
            if (bgmEl) {
              // BGMの再生位置を該当フェーズ開始へ移動（Chrome対策: 再生→シーク）
              const target = (PHASES[idx] && PHASES[idx].start) ? (PHASES[idx].start + 0.2) : 0;
              try { await seekBgmTo(target); } catch(_){}
            }
            // 次回開始時のターゲット秒を記録
            try { devBgmStartAtSec = (PHASES[idx] && PHASES[idx].start) ? (PHASES[idx].start + 0.2) : 0; } catch(_){}
            // 即時適用（ゲーム未開始/一時停止/無音でも反映）
            applyPhaseImmediate(name);
            console.log('[DEV] Jump phase ->', name);
          } catch (_) { /* noop */ }
        }
        try { window.jumpToPhase = jumpToPhase; } catch(_){}
        // プレイヤーのフェーズ別サイズ（見た目＋当たり判定）
        // 仕様: 初期＝旧第3階層の大きさ。各フェーズで 100/90/80/70%（影も一致）、ジャンプ力や速度は変更しない。
        const DESIGN_BASE_SCALE = 0.6; // 旧実装のphase3相当を基準にする
        function phaseScale(phaseName){
          if (phaseName === 'phase2') return 0.9;
          if (phaseName === 'phase3') return 0.8;
          if (phaseName === 'final')  return 0.7;
          return 1.0; // phase1
        }
        function setPlayerScaleTarget(scale){
          player.scaleStart = player.scale;
          player.scaleTarget = scale;
          player.scaleLerpT = 0;
          player.scaleLerpDur = 1.0; // 1秒で補間
        }
        function applyPhasePlayerTuning(phaseName) {
          const target = DESIGN_BASE_SCALE * phaseScale(phaseName);
          setPlayerScaleTarget(target);
        }

        function applyDifficulty(params) {
          world.scrollSpeedMult = params.scrollSpeedMult;
          world.platformSpeedGain = params.platformSpeedGain;
          world.platformGapScale = params.platformGapScale;
          world.sugarRate = params.sugarRate;
          world.bgTint = params.bgTint;
          world.hudColor = params.hudColor;
        }

        const audio = {
          enabled: true,
          ctx: null,
          ensure() {
            if (!this.ctx) {
              const AC = window.AudioContext || window.webkitAudioContext;
              if (!AC) return null;
              this.ctx = new AC();
            }
            return this.ctx;
          },
          resume() {
            if (!this.enabled) return;
            const ctx = this.ensure();
            if (ctx && ctx.state === 'suspended') ctx.resume();
          },
          scheduleNoiseBurst(t, dur = 0.12, gain = 0.035) {
            if (!this.enabled) return;
            const ctx = this.ensure();
            if (!ctx) return;
            // ホワイトノイズの短いバーストで「チャッ」を表現
            const buffer = ctx.createBuffer(1, Math.max(1, Math.floor(dur * ctx.sampleRate)), ctx.sampleRate);
            const data = buffer.getChannelData(0);
            for (let i = 0; i < data.length; i++) {
              // 短い減衰を付与
              const decay = 1 - i / data.length;
              data[i] = (Math.random() * 2 - 1) * decay;
            }
            const src = ctx.createBufferSource();
            src.buffer = buffer;
            const g = ctx.createGain();
            g.gain.setValueAtTime(Math.max(0.0001, gain), t);
            g.gain.exponentialRampToValueAtTime(0.0001, t + dur);
            src.connect(g).connect(ctx.destination);
            src.start(t);
            src.stop(t + dur);
          },
          scheduleBeep(t, freq, dur = 0.08, type = 'sine', gain = 0.04) {
            if (!this.enabled) return;
            const ctx = this.ensure();
            if (!ctx) return;
            const osc = ctx.createOscillator();
            const g = ctx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, t);
            g.gain.setValueAtTime(Math.max(0.0001, gain), t);
            g.gain.exponentialRampToValueAtTime(0.0001, t + dur);
            osc.connect(g).connect(ctx.destination);
            osc.start(t);
            osc.stop(t + dur);
          },
          scheduleSweep(t, f1, f2, dur = 0.18, type = 'sine', gain = 0.035) {
            if (!this.enabled) return;
            const ctx = this.ensure();
            if (!ctx) return;
            const osc = ctx.createOscillator();
            const g = ctx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(f1, t);
            osc.frequency.linearRampToValueAtTime(f2, t + dur);
            g.gain.setValueAtTime(Math.max(0.0001, gain), t);
            g.gain.exponentialRampToValueAtTime(0.0001, t + dur);
            osc.connect(g).connect(ctx.destination);
            osc.start(t);
            osc.stop(t + dur);
          },
          seq(steps) {
            if (!this.enabled) return;
            const ctx = this.ensure();
            if (!ctx) return;
            let t = ctx.currentTime;
            for (const st of steps) {
              if (!st || !st.length) continue;
              if (st[0] === 'beep') {
                const [, f, d = 0.08, ty = 'sine', g = 0.04] = st;
                this.scheduleBeep(t, f, d, ty, g);
                t += d + 0.01;
              } else if (st[0] === 'sweep') {
                const [, f1, f2, d = 0.18, ty = 'sine', g = 0.035] = st;
                this.scheduleSweep(t, f1, f2, d, ty, g);
                t += d + 0.01;
              }
            }
          }
        };
        // 開発用: BGMを確実に指定秒にシークするユーティリティ
        async function seekBgmTo(sec){
          try {
            const a = document.getElementById('bgm');
            if (!a) return;
            // メタデータ待ち
            if (a.readyState < 1) {
              await new Promise(r=>{
                const on = ()=>{ try{a.removeEventListener('loadedmetadata', on);}catch(_){} r(); };
                try{ a.addEventListener('loadedmetadata', on, {once:true}); }catch(_){ r(); }
              });
            }
            // 一度再生を開始してからシーク（Chrome対策）
            try { await a.play(); } catch(_) {}
            try {
              if (typeof a.fastSeek === 'function') a.fastSeek(sec); else a.currentTime = sec;
            } catch(_) {}
            // seeked 完了待ち
            await new Promise(r=>{
              let done = false;
              const t = setTimeout(()=>{ if (!done) r(); }, 250);
              const onSeek = ()=>{ if (done) return; done = true; clearTimeout(t); try{ a.removeEventListener('seeked', onSeek);}catch(_){} r(); };
              try { a.addEventListener('seeked', onSeek, { once:true }); } catch(_) { clearTimeout(t); r(); }
            });
            // 期待位置に到達していなければ Media Fragments でフォールバック
            try {
              const cur = Number(a.currentTime||0);
              if (Math.abs(cur - sec) > 1.0) {
                const u = new URL(a.currentSrc || a.src, location.href);
                u.hash = `t=${Math.max(0, Math.floor(sec))}`;
                const wasLoop = a.loop;
                a.src = u.toString();
                a.load();
                a.loop = wasLoop;
                try { await a.play(); } catch(_) {}
              }
            } catch(_) {}
            // 直後にpauseに戻す（必要なら）
            if (!state.running) try { a.pause(); } catch(_) {}
          } catch(_) {}
        }

        const sfxPlay = {
          start: () => audio.seq([
            ['sweep', 420, 680, 0.18, 'triangle', 0.04],
            ['beep', 760, 0.06, 'triangle', 0.03],
          ]),
          land: () => audio.seq([
            ['beep', 720, 0.05, 'square', 0.035],
          ]),
          firstLand: () => { // 「チャッ」短発（0.1〜0.2秒、小さめ音量）
            const ctx = audio.ensure();
            if (!ctx) return;
            const t = ctx.currentTime;
            audio.scheduleNoiseBurst(t, 0.12, 0.03);
          },
          over: () => audio.seq([
            ['sweep', 600, 240, 0.28, 'sawtooth', 0.03],
          ]),
          jump: () => audio.seq([
            ['sweep', 520, 820, 0.12, 'triangle', 0.035],
          ]),
          pick: () => audio.seq([
            ['beep', 980, 0.05, 'triangle', 0.03],
            ['beep', 1240, 0.04, 'sine', 0.025],
          ]),
          pause: () => audio.seq([
            ['beep', 440, 0.04, 'sine', 0.02],
          ]),
          resume: () => audio.seq([
            ['beep', 660, 0.04, 'sine', 0.02],
          ]),
          combo: () => audio.seq([
            ['beep', 880, 0.05, 'triangle', 0.03],
            ['beep', 1100, 0.05, 'sine', 0.025],
          ]),
          fever: () => audio.seq([
            ['sweep', 500, 1200, 0.22, 'triangle', 0.04],
            ['beep', 1400, 0.06, 'square', 0.03],
          ]),
        };

        // （フェーズ4のエンドロール機能は削除）

        // 初回操作でオーディオを解禁
        const bgmEl = document.getElementById('bgm');
        let bgmEnabled = true;
        // 参考画像（色抽出用・表示には使わない）
        const refImg = new Image();
        let refReady = false;
        refImg.onload = () => { refReady = true; try { derivePaletteFromRef(); } catch(_){} };
        refImg.onerror = () => { refReady = false; };
        refImg.src = 'assets/IMG_7876.jpg';

        // フェーズ別背景画像
        const phaseBackgrounds = {
          phase1: new Image(),
          phase2: new Image(),
          phase3: new Image(),
          final: new Image()
        };
        let backgroundsReady = { phase1: false, phase2: false, phase3: false, final: false };
        
        phaseBackgrounds.phase1.onload = () => { backgroundsReady.phase1 = true; };
        phaseBackgrounds.phase1.onerror = () => { backgroundsReady.phase1 = false; };
        phaseBackgrounds.phase1.src = 'assets/phase1-bg.png';
        
        phaseBackgrounds.phase2.onload = () => { backgroundsReady.phase2 = true; };
        phaseBackgrounds.phase2.onerror = () => { backgroundsReady.phase2 = false; };
        phaseBackgrounds.phase2.src = 'assets/phase2-bg.png';
        
        phaseBackgrounds.phase3.onload = () => { backgroundsReady.phase3 = true; };
        phaseBackgrounds.phase3.onerror = () => { backgroundsReady.phase3 = false; };
        phaseBackgrounds.phase3.src = 'assets/phase3-bg.png';
        
        phaseBackgrounds.final.onload = () => { backgroundsReady.final = true; };
        phaseBackgrounds.final.onerror = () => { backgroundsReady.final = false; };
        phaseBackgrounds.final.src = 'assets/final-bg.png';

        // サブフェーズ用の7枚背景（固定定数 BACKGROUNDS）
        const BACKGROUNDS = [
          'assets/111.png','assets/222.png','assets/333.png',
          'assets/444.png','assets/555.png','assets/666.png','assets/777.png'
        ];
        const BG_STEP_IMAGES = BACKGROUNDS.map(src => {
          const im = new Image();
          im.onload = () => {/* noop: ready */};
          im.onerror = () => { try { console.warn('[BG] failed to load:', src); } catch(_){} };
          im.src = src;
          return im;
        });

        // キャラスプライト（任意）：assets/normal.png（通常）、assets/sleep.png（ゲームオーバー／赤バー上）
        const charSprite = new Image();
        let charSpriteReady = false;
        charSprite.onload = () => { charSpriteReady = true; };
        charSprite.onerror = () => { try { if (charSprite && charSprite.src && charSprite.src.indexOf(PLAYER_IMG) !== -1) { charSprite.src = PLAYER_FALLBACK; } } catch(_){} charSpriteReady = false; };
        const PLAYER_IMG = 'assets/com.apple.Foundation.NSItemProvider.ran8JX-removebg-preview.png';
        const PLAYER_FALLBACK = 'assets/character.png';
        charSprite.src = PLAYER_IMG;
        const charSpriteSleep = new Image();
        let charSpriteSleepReady = false;
        charSpriteSleep.onload = () => { charSpriteSleepReady = true; };
        charSpriteSleep.onerror = () => { try { if (charSpriteSleep && charSpriteSleep.src && charSpriteSleep.src.indexOf(PLAYER_IMG) !== -1) { charSpriteSleep.src = PLAYER_FALLBACK; } } catch(_){} charSpriteSleepReady = false; };
        charSpriteSleep.src = PLAYER_IMG;
        
        // ベッドスプライト（赤いバー代替）
        const bedSprite = new Image();
        let bedSpriteReady = false;
        bedSprite.onload = () => { bedSpriteReady = true; console.log('ベッド画像読み込み成功'); };
        bedSprite.onerror = () => { bedSpriteReady = false; console.log('ベッド画像読み込み失敗'); };
        // 404回避：実ファイル配置に合わせて正しいパスへ
        bedSprite.src = 'scripts/sprites_bed.png';
        
        function tryPlayBgm() {
          if (!bgmEnabled || !bgmEl) return;
          const p = bgmEl.play();
          if (p && p.catch) p.catch(() => {});
        }
        if (bgmEl) { bgmEl.volume = 0.35; }
        // DEV時はメタデータ取得を優先（シークの即応性を高める）
        try { if (DEV && DEV.dev && bgmEl) bgmEl.preload = 'auto'; } catch(_){}

        // BGM制御（フェード・停止・再生位置管理・デバウンス）
        // DEV: 次回再生開始位置（フェーズジャンプが指定したときに使用）
        let devBgmStartAtSec = null;
        const BGM = {
          get el(){ return bgmEl; },
          targetVol: (bgmEl ? bgmEl.volume : 0.35),
          fadeRaf: null,
          gameOverHandled: false,
          fadeFromCurrent(durSec = 0.8){
            if (!this.el || !bgmEnabled) return;
            this.clearFade();
            this.setVolume(0);
            const start = performance.now();
            const endVol = this.targetVol;
            const step = (now) => {
              const p = Math.min(1, (now - start) / (durSec * 1000));
              this.setVolume(endVol * p);
              if (p < 1) this.fadeRaf = requestAnimationFrame(step); else this.fadeRaf = null;
            };
            this.fadeRaf = requestAnimationFrame(step);
          },
          // 指定秒へ安全にシーク（loadedmetadata/seeked待ち）
          seekTo(targetSec, autoplay = true) {
            if (!this.el) return;
            this.clearFade();
            const el = this.el;
            const target = Math.max(0, Number(targetSec) || 0);
            const setAndMaybePlay = () => {
              try {
                if (typeof el.fastSeek === 'function') el.fastSeek(target);
                else el.currentTime = target;
              } catch(_) {}
              // ユーザー操作中のキー押下で呼ばれるため、再生を明示再開
              if (autoplay) tryPlayBgm();
            };
            // メタデータが無い場合のみ load して loadedmetadata 後に実行
            if (el.readyState === 0 || !isFinite(el.duration || NaN)) {
              try {
                const onMeta = () => { try { el.removeEventListener('loadedmetadata', onMeta); } catch(_){} setAndMaybePlay(); };
                el.addEventListener('loadedmetadata', onMeta, { once: true });
              } catch(_) {}
              try { el.preload = 'auto'; el.load(); } catch(_){}
            } else {
              setAndMaybePlay();
            }
          },
          clearFade() {
            if (this.fadeRaf != null) {
              try { cancelAnimationFrame(this.fadeRaf); } catch(_){}
              this.fadeRaf = null;
            }
          },
          setVolume(v){ if (!this.el) return; this.el.volume = Math.max(0, Math.min(1, v)); },
          stopAndReset() {
            this.clearFade();
            if (!this.el) return;
            try { this.el.pause(); } catch(_){}
            try { this.el.currentTime = 0; } catch(_){}
          },
          fadeInFromZero(durSec = 0.8, targetTime = 0) {
            if (!this.el || !bgmEnabled) return;
            this.clearFade();
            // 再生は必ず stop→seek0→play の順
            try { this.el.pause(); } catch(_){}
            // メタデータ未読込でも確実にターゲット時刻へ
            const tgt = Math.max(0, targetTime||0);
            const setTime = () => { try { this.el.currentTime = tgt; } catch(_){} };
            const beginFade = () => {
              const start = performance.now();
              const startVol = 0;
              const endVol = this.targetVol;
              const step = (now) => {
                const p = Math.min(1, (now - start) / (durSec * 1000));
                this.setVolume(startVol + (endVol - startVol) * p);
                if (p < 1) {
                  this.fadeRaf = requestAnimationFrame(step);
                } else {
                  this.fadeRaf = null;
                  this.setVolume(endVol);
                }
              };
              this.fadeRaf = requestAnimationFrame(step);
            };
            if (tgt > 0 && !(this.el.readyState >= 1 && isFinite(this.el.duration || NaN))) {
              const onMeta = () => { try { setTime(); } finally { try { this.el.removeEventListener('loadedmetadata', onMeta); } catch(_){} } };
              try { this.el.addEventListener('loadedmetadata', onMeta, { once: true }); } catch(_){}
              try { this.el.load(); } catch(_){}
              // 再生・フェードはメタデータ読込後に実行
              const onCanPlay = () => {
                try { this.el.removeEventListener('canplay', onCanPlay); } catch(_){}
                tryPlayBgm();
                beginFade();
              };
              try { this.el.addEventListener('canplay', onCanPlay, { once: true }); } catch(_){}
            } else {
              setTime();
              this.setVolume(0);
              tryPlayBgm();
              beginFade();
            }
          },
          onGameOver() {
            if (this.gameOverHandled) return; // 多重発火防止
            this.gameOverHandled = true;
            // 要件順序：停止→位置0→必要なら再開（今回は停止のまま）
            this.stopAndReset();
          },
          async onStartPlay() {
            // リトライ開始時：曲頭からフェードインして再生
            this.clearFade();
            this.gameOverHandled = false;
            if (!bgmEnabled) {
              // ミュート時は位置だけ0に
              this.stopAndReset();
              return;
            }
            // DEVモード中は選択フェーズ/直前のジャンプ指定時刻から再生
            let target = (typeof devBgmStartAtSec === 'number') ? devBgmStartAtSec : 0;
            try {
              if (!target && window.DEV && window.DEV.dev && window.DEV.phase && Array.isArray(PHASES)) {
                const p = PHASES.find(x => x && x.name === window.DEV.phase);
                if (p && typeof p.start === 'number') target = (p.start || 0) + 0.2;
              }
            } catch(_){}
            if (target > 0) {
              await seekBgmTo(target);
              this.fadeFromCurrent(0.8);
            } else {
              this.fadeInFromZero(0.8, 0);
            }
          },
          resetDebounce(){ this.gameOverHandled = false; }
        };
        window.addEventListener('pointerdown', () => { audio.resume(); tryPlayBgm(); });
        window.addEventListener('keydown', () => { audio.resume(); tryPlayBgm(); });

        // フェーズ表示バッジ
        const phaseBadge = document.createElement('div');
        phaseBadge.style.cssText = `
          position: absolute; right: 12px; top: 96px; padding: 6px 10px; 
          background: rgba(15,16,32,0.55); color: #ffffff; 
          font: 600 28px system-ui, -apple-system, sans-serif; 
          border-radius: 8px; box-shadow: 0 2px 10px rgba(0,0,0,0.25);
          backdrop-filter: blur(2px); z-index: 100;
          opacity: 0; transition: opacity 0.4s ease, color 0.8s ease;
        `;
        phaseBadge.textContent = '';
        phaseBadge.className = 'phase-badge';
        document.getElementById('wrap').appendChild(phaseBadge);

        // フェーズ3の中央固定テキスト・囁きは削除（使用しない）

        let phaseBadgeHideTimer = null;
        // 右上フェーズ名は非表示化するため更新処理は空にする
        function showPhaseBadge(_text) { /* no-op: hidden */ }

        // BGM時間監視とフェーズ制御
        function updatePhase() {
          if (!bgmEl || bgmEl.paused || !state.running) return;
          // DEV強制フェーズ
          let phase = null;
          if (DEV.dev && DEV.phase) {
            phase = DEV.phase;
          } else {
            const t = Math.floor(bgmEl.currentTime);
            phase = resolvePhase(t);
          }
          
          if (phase !== currentPhase) {
            const prev = currentPhase;
            currentPhase = phase;
            applyDifficulty(DIFFICULTY[phase]);
            applyPhasePlayerTuning(currentPhase);
            // 速度変動リセット（位相は継続、スパイクのみリスケジュール）
            scheduleNextSpike();
            
            // 背景テキスト/囁きを一度リセットしてから、フェーズに応じて再初期化
            BG.tickerText = '';
            BG.tickerX = 0;
            BG.whisperActive = false;
            BG.whisperText = '';
            BG.whisperAlpha = 0;
            BG.whisperTimer = 0;
            BG.p2Active = false;
            BG.p2Messages = [];
            BG.p2Index = 0;
            BG.p2X = 0;
            BG.p3Active = false;
            BG.p3Items = [];
            BG.p3SpawnTimer = 0;
            // フェーズ1 → 他フェーズへ移行時の徹底クリーンアップ
            if (prev === 'phase1' && phase !== 'phase1') {
              PhaseCleanup.clearPhase1();
            }
            initBG(phase);

            // （フェーズ4のエンドロール呼び出しは削除）

            // フェーズ切替時：スピード係数をリセットし、フェーズ中に極端なカーブで加速
            phaseTimer = 0;
            phaseLenSec = phaseDurationFor(currentPhase);
            if (currentPhase === 'phase1') {
              // 線形：ゆっくり→少し速く
              phaseSpeedProfile = { start: 1.0, mid: null, end: 1.5, split: 0.5 };
            } else if (currentPhase === 'phase2') {
              // 線形：開始はゆっくり→終盤へ直線的に加速
              phaseSpeedProfile = { start: 1.5, mid: null, end: 2.5, split: 0.5 };
            } else if (currentPhase === 'phase3') {
              // 線形：開始はややゆっくり→高めへ直線的に加速
              const start = 1.0 + Math.random() * 0.2; // 1.0〜1.2
              const end = 2.8 + Math.random() * 0.2;   // 2.8〜3.0
              phaseSpeedProfile = { start, mid: null, end, split: 0.5 };
            } else if (currentPhase === 'final') {
              // 前半は加速、後半は最大帯で維持（波打ちは別処理）
              phaseSpeedProfile = { start: 2.5, mid: null, end: 3.0, split: 0.5 };
            }
            speedCtl.factor = phaseSpeedProfile.start;
            world.scrollSpeed = speedCtl.base * speedCtl.factor;

            // フェーズ3突入時：全体を一時的にスローモーション（0.5x → 1.0x）
            if (currentPhase === 'phase3') {
              timeCtl.active = true;
              timeCtl.from = 0.5;
              timeCtl.target = 1.0;
              timeCtl.t = 0;
              timeCtl.duration = 3.2; // 数秒かけて元の速度へ
              timeCtl.factor = timeCtl.from;
            } else {
              // それ以外のフェーズでは通常速度
              timeCtl.active = false;
              timeCtl.from = 1.0;
              timeCtl.target = 1.0;
              timeCtl.t = 0;
              timeCtl.duration = 0;
              timeCtl.factor = 1.0;
            }
            
            // フェーズ変更演出
            phaseTransition.active = true;
            phaseTransition.timer = 0;
            
            // フェーズ表示更新
            const phaseLabels = {
              phase1: '現世のうつしよ ― 光の回廊',
              phase2: '第二階層 ― 揺らぎの明晰夢',
              phase3: '第三階層 ― 時間が伸びる世界',
              final:  '夢の楽園 ― 夢の楽園'
            };
            phaseBadge.style.color = world.hudColor;
            // フェーズ切替テキスト（中心ポップアップ）を入れ替え表示
            // 既存のフェーズ用ポップを消してから追加
            popups = popups.filter(p => p.kind !== 'phase');
            popups.push({
              kind: 'phase',
              x: (canvas.clientWidth/2)||160, 
              y: 100, 
              vx: 0, vy: -12, 
              life: 0, 
              text: phaseLabels[phase], 
              color: world.hudColor
            });
            // バッジはフェーズ中 常時表示（フェードインのみ）
            showPhaseBadge(phaseLabels[phase]);
            
            // フェーズ変更サウンド（フェーズ別）
            if (phase === 'final') {
              // ファイナルフェーズは特別なサウンド
              audio.seq([
                ['sweep', 600, 1800, 0.35, 'sawtooth', 0.06],
                ['beep', 2000, 0.12, 'triangle', 0.05],
                ['sweep', 1200, 800, 0.2, 'sine', 0.04],
              ]);
            } else {
              audio.seq([
                ['sweep', 800, 1400, 0.25, 'triangle', 0.05],
                ['beep', 1600, 0.08, 'sine', 0.04],
              ]);
            }
            
            // 既存のフェーズ変更ポップアップは上で置換済み
            
            // ファイナルフェーズは追加演出
            if (phase === 'final') {
              phaseTransition.duration = 3.0; // 長めの演出
              screenShake = { active: true, intensity: 8, timer: 0, duration: 2.5 }; // 強めの画面揺れ
              popups.push({
                x: (canvas.clientWidth/2)||160, 
                y: 150, 
                vx: 0, vy: -8, 
                life: 0, 
                text: 'CLIMAX!', 
                color: '#ff6b6b'
              });
            } else {
              phaseTransition.duration = 2.0;
              screenShake = { active: true, intensity: 4, timer: 0, duration: 1.2 }; // 軽めの画面揺れ
            }
            
            console.log('[PHASE CHANGE]', phase);
          }
        }

        // SFXトグル
        const sfxBtn = document.getElementById('sfxBtn');
        // 設定の復元
        try {
          const sfxSaved = localStorage.getItem('glucoseman_sfx');
          if (sfxSaved === '0') audio.enabled = false;
        } catch (_) {}
        sfxBtn.textContent = 'SFX: ' + (audio.enabled ? 'ON' : 'OFF');
        sfxBtn.addEventListener('click', () => {
          audio.enabled = !audio.enabled;
          sfxBtn.textContent = 'SFX: ' + (audio.enabled ? 'ON' : 'OFF');
          try { localStorage.setItem('glucoseman_sfx', audio.enabled ? '1' : '0'); } catch (_) {}
          if (audio.enabled) audio.resume();
        });

        // BGMトグル
        const bgmBtn = document.getElementById('bgmBtn');
        // 設定の復元
        try {
          const bgmSaved = localStorage.getItem('glucoseman_bgm');
          if (bgmSaved === '0') bgmEnabled = false;
        } catch (_) {}
        bgmBtn.textContent = 'BGM: ' + (bgmEnabled ? 'ON' : 'OFF');
        bgmBtn.addEventListener('click', () => {
          bgmEnabled = !bgmEnabled;
          bgmBtn.textContent = 'BGM: ' + (bgmEnabled ? 'ON' : 'OFF');
          try { localStorage.setItem('glucoseman_bgm', bgmEnabled ? '1' : '0'); } catch (_) {}
          if (bgmEl) {
            if (bgmEnabled) tryPlayBgm(); else bgmEl.pause();
          }
        });

        const world = {
          scrollSpeed: 60, // 初速を控えめに
          gravity: 900, // 落下を緩やかに
          maxFall: 950,
          jumpSpeed: 520,
          platformMinW: 90,
          platformMaxW: 200,
          // ベースの縦間隔をやや広げる（初期: 80〜120）
          platformGapMin: 80,
          platformGapMax: 120,
          platformH: 16,
          platformSpeedGain: 0.006, // 難易度上昇を緩やかに
          platformColor1: '#3ad1ff',
          platformColor2: '#58ffa9',
          // フェーズ制御用パラメータ
          scrollSpeedMult: 1.0,
          platformGapScale: 1.0,
          sugarRate: 0.32,
          bgTint: 'rgba(0,0,0,0.0)',
          hudColor: '#ffffff'
        };
        
        // 天蓋（画面上部の半円アーチ）設定（見やすさ強化）
        const CANOPY = {
          radiusScale: 0.62,
          thickness: 28,       // 太めにして視認性アップ
          bandFactor: 0.9,     // 線の周辺帯域（当たり判定）
          apexLimitFactor: 0.22, // 上端付近のみに限定（Rの22%まで）
          offsetY: 14          // 画面上から少し下げて描画（見やすさ）
        };

        const player = {
          x: 0, y: 0,
          baseW: 84, baseH: 132,
          w: 84, h: 132,
          scale: 1.0,
          scaleStart: 1.0,
          scaleTarget: 1.0,
          scaleLerpT: 0,
          scaleLerpDur: 1.0,
          vx: 0, vy: 0,
          speed: 238, // horizontal (0.85x)
          onGround: false,
          groundId: null,
          airJumpsLeft: 0,
        };

        let platforms = [];
        let sugars = [];
        let platformIdCounter = 1;
        let sugarIdCounter = 1;
        let popups = [];
        // 足場生成タイマー（同時数と生成間隔の制御）
        let pfSpawnTimer = 0;
        let pfNextDelay = 1.8;
        let lastSpawnEdge = false; // 直前スポーンがエッジ帯だったか

        // フェーズ別スコア
        function scoreForCurrentPhase() {
          switch (currentPhase) {
            case 'phase1': return 100;
            case 'phase2': return 150;
            case 'phase3': return 200;
            case 'final':  return 300;
            default: return 100;
          }
        }

        function resize() {
          const dpr = Math.max(1, Math.min(2, window.devicePixelRatio || 1));
          const w = Math.floor(window.innerWidth);
          const h = Math.floor(window.innerHeight);
          canvas.width = Math.floor(w * dpr);
          canvas.height = Math.floor(h * dpr);
          canvas.style.width = w + 'px';
          canvas.style.height = h + 'px';
          ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
        }

        window.addEventListener('resize', resize);
        resize();

        function reset() {
          state.running = true;
          state.gameOver = false;
          state.paused = false;
          state.score = 0;
          state.depth = 0;
          state.time = 0;
          state.sugars = 0;
          state.comboCount = 0;
          state.comboMult = 1;
          state.comboTime = 0;
          state.fever = false;
          state.feverTime = 0;
          state.pickStreak = 0;
          state.scoredPids = new Set();
          initBG();
          // 縦画面（スマホ）向けに軽くスケーリング
          const Hview = canvas.clientHeight || window.innerHeight;
          const scale = Math.max(0.75, Math.min(1.1, Hview / 800));
          world.scrollSpeed = 60 * scale;
          // スピード制御の基準値（ゲーム開始時）
          speedCtl.base = world.scrollSpeed;
          phaseTimer = 0;
          phaseLenSec = phaseDurationFor('phase1');
          phaseSpeedProfile = { start: 1.0, mid: null, end: 1.5, split: 0.5 };
          speedCtl.factor = phaseSpeedProfile.start;
          world.jumpSpeed = 520 * Math.max(0.9, Math.min(1.06, scale + 0.06));
          // 初期フェーズは 80〜120 を基準（スケール適用）
          world.platformGapMin = Math.round(80 * scale);
          world.platformGapMax = Math.round(120 * scale);
          platforms = [];
          sugars = [];
          popups = [];

          // スタート足場（赤バー）を画面最下部に固定し、その上から開始
          const startW = Math.min(Math.max(220, Math.floor(canvas.clientWidth * 0.6)), 280);
          const startX = Math.max(0, (canvas.clientWidth - startW) / 2);
          const startH = world.platformH + 4;
          const startY = (canvas.clientHeight || window.innerHeight) - startH;
          const startPf = { id: platformIdCounter++, x: startX, y: startY, w: startW, h: startH, hue: 0, safe: true };
          platforms.push(startPf);
          maybeAddSugar(startPf);

          player.x = startPf.x + startPf.w / 2 - player.w / 2;
          player.y = startPf.y - player.h;
          player.vx = 0; player.vy = 0; player.onGround = true; player.groundId = startPf.id; player.airJumpsLeft = state.fever ? 1 : 0;
          state.safePlatformId = startPf.id;
          state.leftSafe = false;
          state.safeFadeT = 0;
          state.safeFading = false;
          state.activated = false;
          state.lastScorePid = null;

          // フェーズシステム初期化
          currentPhase = 'phase1';
          applyDifficulty(DIFFICULTY.phase1);
          applyPhasePlayerTuning(currentPhase);
          // 初期は即時に目標スケールへ反映（開始時は補間しない）
          (function(){
            const target = DESIGN_BASE_SCALE * phaseScale(currentPhase);
            const oldW = player.w, oldH = player.h;
            const footY = player.y + oldH;
            const cx = player.x + oldW / 2;
            player.scale = target;
            player.scaleStart = target;
            player.scaleTarget = target;
            player.scaleLerpT = player.scaleLerpDur;
            player.w = Math.round(player.baseW * target);
            player.h = Math.round(player.baseH * target);
            player.y = footY - player.h;
            player.x = Math.round(cx - player.w / 2);
          })();
          phaseTransition.active = false;
          // フェーズ表示（フェーズ中も常時表示、フェードインのみ）
          if (phaseBadge) {
            phaseBadge.style.color = world.hudColor;
            showPhaseBadge('現世のうつしよ ― 光の回廊');
          }

          // 初期の通常バーは赤バーより上に生成（ジャンプ必須）
          const cfg0 = spawnConfigForPhase(currentPhase);
          const gapMin = Math.floor(world.platformGapMin * world.platformGapScale);
          const gapMax = Math.floor(world.platformGapMax * world.platformGapScale);
          let y = startY - rand(gapMin, gapMax);
          // 初期生成数を増やし、開始直後から4〜6個が見える密度に調整
          const initialCount = Math.min(5, Math.max(4, cfg0.limit));
          for (let i = 0; i < initialCount && y > -200; i++) {
            platforms.push(makePlatform(y));
            y -= rand(gapMin, gapMax);
          }
          pfSpawnTimer = 0;
          pfNextDelay = randf(cfg0.min, cfg0.max);
        }

        function makePlatform(y) {
          // 基準幅からフェーズに応じて縮小（基本: 40〜60%、後半: 30〜50%）
          const baseW = rand(world.platformMinW, world.platformMaxW);
          const useNarrower = (currentPhase === 'phase2' || currentPhase === 'phase3' || currentPhase === 'final');
          const sMin = useNarrower ? 0.30 : 0.40;
          const sMax = useNarrower ? 0.50 : 0.60;
          // フェーズ段階ごとの追加短縮（phase2:0.95, phase3:0.90, final:0.80）
          const phaseWMult = (currentPhase === 'final') ? 0.80 : (currentPhase === 'phase3' ? 0.90 : (currentPhase === 'phase2' ? 0.95 : 1.00));
          const s = (sMin + Math.random() * (sMax - sMin)) * phaseWMult;
          const w = Math.max(24, Math.floor(baseW * s));

          // X位置は一様乱数で決定。端の連続出現を抑制（前回がエッジ帯の場合は再抽選）。
          const W = canvas.clientWidth || 320;
          const pad = 28; // 24〜32pxの安全マージン
          const minX = pad;
          const maxX = Math.max(pad, W - pad - w);
          const edgeFrac = 0.11; // 10〜12%のエッジ帯
          const isEdgeX = (xx) => {
            const cx = xx + w / 2;
            const leftEnd = W * edgeFrac;
            const rightStart = W * (1 - edgeFrac);
            return (cx < leftEnd) || (cx > rightStart);
          };
          let x = minX + Math.floor(Math.random() * Math.max(1, (maxX - minX)));
          if (lastSpawnEdge && isEdgeX(x)) {
            for (let i = 0; i < 8 && isEdgeX(x); i++) {
              x = minX + Math.floor(Math.random() * Math.max(1, (maxX - minX)));
            }
          }
          lastSpawnEdge = isEdgeX(x);

          const pf = { id: platformIdCounter++, x, y, w, h: world.platformH, hue: Math.random() * 360, stayT: 0, fading: false, fadeT: 0, decayT: null };

          // 一部の足場を左右にスイングさせる（ゆっくり〜中速）
          // フェーズが進むほど出現確率を少し上げる
          const moveChance = (currentPhase === 'phase1') ? 0.20 : (currentPhase === 'final' ? 0.40 : 0.30);
          if (Math.random() < moveChance) {
            // 左端x（pf.x）を中心にスイング。端にはみ出さないよう振幅を制限
            const minX = pad;
            const maxX = Math.max(pad, W - pad - w);
            const desiredAmp = rand(24, 60);
            const clampAmp = Math.max(8, Math.min(desiredAmp, x - minX, maxX - x));
            // 目標最大速度（20〜90px/s）から角速度を算出（vmax = A * omega）
            const vmax = randf(20, 90);
            const omega = Math.max(0.2, Math.min(2.4, vmax / Math.max(8, clampAmp)));
            pf.sway = {
              center: x,
              amp: Math.floor(clampAmp),
              t: Math.random() * Math.PI * 2,
              omega,
              prevX: x,
            };
          }
          maybeAddSugar(pf);
          return pf;
        }

        function rand(a, b) { return Math.floor(a + Math.random() * (b - a)); }
        function randf(a, b) { return a + Math.random() * (b - a); }
        function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
        // 足場の消滅秒数（着地から何秒で消えるか）
        const PLATFORM_DECAY_LIMIT = 1.5;
        // 画面内に見える非セーフ足場の最低保証数
        const MIN_VISIBLE_PLATFORMS = 3;
        // 検証用: X生成ヒストグラム（左右25%/中央50%）
        window.gmDebug = window.gmDebug || {};
        window.gmDebug.runSpawnHistogram = function(times = 1000) {
          const W = canvas.clientWidth || 320;
          const pad = 28; const w = 80;
          const minX = pad; const maxX = Math.max(pad, W - pad - w);
          const L = 0.25 * W, R = 0.75 * W;
          const edgeFrac = 0.11;
          const isEdge = (xx)=>{ const cx=xx+w/2; return (cx < W*edgeFrac)||(cx > W*(1-edgeFrac)); };
          let left=0, center=0, right=0, prevEdge=false;
          for (let i=0;i<times;i++){
            let x = minX + Math.floor(Math.random() * Math.max(1, (maxX - minX)));
            if (prevEdge && isEdge(x)) {
              for (let t=0;t<8 && isEdge(x);t++) x = minX + Math.floor(Math.random() * Math.max(1, (maxX - minX)));
            }
            prevEdge = isEdge(x);
            const cx = x + w/2;
            if (cx < L) left++; else if (cx > R) right++; else center++;
          }
          console.log('Spawn histogram (L/C/R):', left, center, right, 'ratio ~', (left/ times).toFixed(2), (center/ times).toFixed(2), (right/ times).toFixed(2));
        };

        // フェーズごとの足場同時数と生成間隔
        function spawnConfigForPhase(phase) {
          // 画面内に常時4〜6個の足場が見えるよう、
          // フェーズごとの同時数上限と生成間隔を調整
          switch (phase) {
            case 'phase2': return { limit: 6, min: 1.3, max: 2.0 };
            case 'phase3': return { limit: 6, min: 1.5, max: 2.2 };
            case 'final':  return { limit: 6, min: 1.7, max: 2.4 };
            case 'phase1':
            default:       return { limit: 6, min: 1.2, max: 1.8 };
          }
        }

        function maybeAddSugar(pf) {
          if (pf && pf.safe) return; // セーフ足場には置かない
          if (Math.random() < world.sugarRate) {
            sugars.push({
              id: sugarIdCounter++,
              x: pf.x + pf.w / 2 - 5,
              y: pf.y - 10,
              r: 7,
              alive: true,
            });
          }
        }

        function currentMultiplier() {
          return state.fever ? 6 : Math.max(1, state.comboMult);
        }

        // セーブ/ロード
        function serializeSave() {
          const data = {
            ver: 1,
            active: true,
            t: Date.now(),
            currentPhase,
            state: {
              running: state.running,
              paused: state.paused,
              gameOver: state.gameOver,
              score: state.score,
              time: state.time,
              best: state.best,
              lastScorePid: state.lastScorePid,
              scoredPids: Array.from(state.scoredPids||[]),
            },
            player: {
              x: player.x, y: player.y, vx: player.vx, vy: player.vy,
              w: player.w, h: player.h, onGround: player.onGround, groundId: player.groundId,
              airJumpsLeft: player.airJumpsLeft,
            },
            world: {
              scrollSpeed: world.scrollSpeed,
              gravity: world.gravity,
              jumpSpeed: world.jumpSpeed,
              platformGapMin: world.platformGapMin,
              platformGapMax: world.platformGapMax,
              platformGapScale: world.platformGapScale,
            },
            counters: { platformIdCounter, sugarIdCounter },
            timers: { pfSpawnTimer: (typeof pfSpawnTimer==='number'?pfSpawnTimer:0), pfNextDelay: (typeof pfNextDelay==='number'?pfNextDelay:1.8), phaseTimer, phaseLenSec },
            arrays: {
              platforms: platforms.map(p => ({ id:p.id,x:p.x,y:p.y,w:p.w,h:p.h,hue:p.hue||0,safe:!!p.safe,stayT:p.stayT||0,fading:!!p.fading,fadeT:p.fadeT||0 })),
              sugars: sugars.map(s => ({ id:s.id,x:s.x,y:s.y,r:s.r,alive:s.alive }))
            }
          };
          return data;
        }

        function tryRestore() {
          try {
            const raw = localStorage.getItem('glucoseman_autosave');
            if (!raw) return false;
            const data = JSON.parse(raw);
            if (!data || !data.active || data.ver !== 1) return false;
            // 復元確認UIを表示（自動開始はしない）
            overlay.style.display = 'flex';
            const panel = document.getElementById('panel');
            panel.innerHTML = `
              <div class="title">続きから再開しますか？</div>
              <div class="small" style="margin-bottom:8px">前回スコア: ${data.state && data.state.score || 0}</div>
              <div class="btn" id="resumeFromSaveBtn">続きから</div>
              <div class="btn" id="startBtn" style="margin-left:8px">最初から</div>
            `;
            const doApply = () => {
              audio.resume();
              BGM.onStartPlay();
              currentPhase = data.currentPhase || 'phase1';
              applyDifficulty(DIFFICULTY[currentPhase]||DIFFICULTY.phase1);
              applyPhasePlayerTuning(currentPhase);
              state.running = true; state.paused = false; state.gameOver = false;
              state.score = (data.state&&data.state.score)||0;
              state.time = (data.state&&data.state.time)||0;
              state.best = Number(localStorage.getItem('glucoseman_best')||state.best||0);
              state.lastScorePid = (data.state&&data.state.lastScorePid)||null;
              state.scoredPids = new Set((data.state&&data.state.scoredPids)||[]);
  
              player.x = data.player.x; player.y = data.player.y; player.vx = data.player.vx; player.vy = data.player.vy;
              player.onGround = !!data.player.onGround; player.groundId = data.player.groundId; player.airJumpsLeft = data.player.airJumpsLeft||0;
  
              world.scrollSpeed = data.world.scrollSpeed; world.gravity = data.world.gravity; world.jumpSpeed = data.world.jumpSpeed;
              world.platformGapMin = data.world.platformGapMin; world.platformGapMax = data.world.platformGapMax; world.platformGapScale = data.world.platformGapScale;
  
              platformIdCounter = data.counters.platformIdCounter; sugarIdCounter = data.counters.sugarIdCounter;
              pfSpawnTimer = (data.timers&&data.timers.pfSpawnTimer)||0; pfNextDelay = (data.timers&&data.timers.pfNextDelay)||1.8; phaseTimer = data.timers.phaseTimer||0; phaseLenSec = data.timers.phaseLenSec||phaseDurationFor(currentPhase);
  
              platforms = (data.arrays&&data.arrays.platforms)||[];
              sugars = (data.arrays&&data.arrays.sugars)||[];
              overlay.style.display = 'none';
              // 物理初期化と初着地グレース（続き直後）
              player.vx = 0; player.vy = 0;
              player.canCollide = true; player.dropThrough = false; player.collisionMask = 'default';
              state.allowFirstLand = true; state.firstLandingTimer = 0.3; state.firstLandingWait = true;
            };
            const resumeBtn = document.getElementById('resumeFromSaveBtn');
            if (resumeBtn) resumeBtn.addEventListener('pointerdown', (ev) => { try { ev.preventDefault(); } catch(_){} doApply(); }, { passive: false });
            return true;
          } catch(_) { return false; }
        }

        function startFever() {
          state.fever = true;
          state.feverTime = 15.0;
          sfxPlay.fever();
          popups.push({x: (canvas.clientWidth/2)||160, y: 120, vx: 0, vy: -16, life: 0, text: 'FEVER!', color: '#ffd96a'});
          // 空中でも即座に2段ジャンプ可能にする
          player.airJumpsLeft = Math.max(player.airJumpsLeft, 1);
        }

        // Input
        const keys = new Set();
        // 左右同時押し対策：最後に押した方向を優先
        const inputOrder = { left: 0, right: 0 };
        const nowMs = () => (typeof performance!=='undefined' && performance.now ? performance.now() : Date.now());
        const JUMP_COYOTE = 0.18; // 離れてからもジャンプできる猶予（操作感向上）
        const JUMP_BUFFER = 0.20; // 押し先行の猶予（誤ミス軽減）
        const LAND_TOL = 8; // 足場上面の吸着許容（px）
        const DETACH_AT_TOP = 6; // 画面上端付近で足場をすり抜けにするしきい値（px）
        const control = { coyote: 0, jumpBuf: 0 };
        window.addEventListener('keydown', (e) => {
          if (e.repeat) return;
          // DEV: フェーズジャンプ（G/H/J/K）。大文字小文字どちらでも可。
          // フェーズジャンプは dev-tools.js 側でのみ処理（重複を避ける）
          if (e.code === 'ArrowLeft' || e.code === 'KeyA') { keys.add('left'); inputOrder.left = nowMs(); }
          if (e.code === 'ArrowRight' || e.code === 'KeyD') { keys.add('right'); inputOrder.right = nowMs(); }
          if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') {
            keys.add('jump');
            control.jumpBuf = JUMP_BUFFER;
          }
          if (e.code === 'Escape') {
            if (state.running && !state.gameOver) {
              if (!state.paused) pauseGame(); else resumeGame();
            }
          }
          if (!state.running && (e.code === 'Enter' || e.code === 'Space')) {
            start();
          }
          if (state.gameOver && (e.code === 'Enter' || e.code === 'Space')) {
            start();
          }
        });
        window.addEventListener('keyup', (e) => {
          if (e.code === 'ArrowLeft' || e.code === 'KeyA') keys.delete('left');
          if (e.code === 'ArrowRight' || e.code === 'KeyD') keys.delete('right');
          if (e.code === 'Space' || e.code === 'ArrowUp' || e.code === 'KeyW') keys.delete('jump');
        });
        
        // 戻るジェスチャ対策：履歴を消費してポーズ
        try { history.replaceState({ gm: 'root' }, '', location.href); } catch(_){}
        window.addEventListener('popstate', (ev) => {
          if (state.running && !state.gameOver) {
            try { history.pushState({ gm: 'play' }, '', location.href); } catch(_){}
            pauseGame();
          }
        });

        // タッチボタン（マルチタッチ対応）
        function bindHold(btn, key, isJump=false) {
          if (!btn) return;
          const down = (ev) => {
            ev.preventDefault();
            keys.add(key);
            if (isJump) control.jumpBuf = JUMP_BUFFER;
            if (key === 'left') inputOrder.left = nowMs();
            if (key === 'right') inputOrder.right = nowMs();
            btn.dataset.pid = ev.pointerId;
            btn.setAttribute('data-on','1');
          };
          const up = (ev) => {
            if (String(btn.dataset.pid) !== String(ev.pointerId)) return;
            keys.delete(key);
            btn.removeAttribute('data-on');
            delete btn.dataset.pid;
          };
          btn.addEventListener('pointerdown', down, {passive:false});
          btn.addEventListener('pointerup', up, {passive:false});
          btn.addEventListener('pointercancel', up, {passive:false});
          btn.addEventListener('pointerleave', up, {passive:false});
        }
        bindHold(document.getElementById('btnLeft'), 'left');
        bindHold(document.getElementById('btnRight'), 'right');
        bindHold(document.getElementById('btnJumpL'), 'jump', true);
        bindHold(document.getElementById('btnJumpR'), 'jump', true);

        startBtn.addEventListener('click', start);
        // スマホ/Chrome対策：pointerdownを最優先（preventDefault→Audio→BGM→start）、clickは補助
        const canStartNow = () => (!state.running && !state.gameOver);
        document.addEventListener('pointerdown', (ev) => {
          if (!canStartNow()) return;
          try { if (ev.target && ev.target.closest && ev.target.closest('#panel')) return; } catch(_){}
          try { ev.preventDefault(); } catch(_){}
          try { audio.resume(); } catch(_){}
          try { tryPlayBgm(); } catch(_){}
          start();
        }, { passive: false, once: true });
        const startBtnEl = document.getElementById('startBtn');
        if (startBtnEl) {
          startBtnEl.addEventListener('pointerdown', (ev) => {
            if (!canStartNow()) return;
            try { ev.preventDefault(); } catch(_){}
            try { audio.resume(); } catch(_){}
            try { tryPlayBgm(); } catch(_){}
            start();
          }, { passive: false });
        }
        function start() {
          console.log('[START]', state.running, state.gameOver);
          overlay.style.display = 'none';
          document.getElementById('panel').innerHTML = panelHTML('running');
          audio.resume();
          sfxPlay.start();
          // BGMは曲頭からフェードイン。多重再生防止のため stop→seek0→play の順。
          BGM.onStartPlay();
          // 戻るジェスチャ対策：ゲーム中はダミー履歴を積む
          try { history.pushState({ gm: 'play' }, '', location.href); } catch(_){}
          reset();
          // 物理初期化と初着地グレース
          player.vx = 0; player.vy = 0;
          player.canCollide = true; player.dropThrough = false; player.collisionMask = 'default';
          state.allowFirstLand = true; state.firstLandingTimer = 0.3; state.firstLandingWait = true;
        }

        function pauseGame() {
          if (!state.running || state.gameOver) return;
          state.paused = true;
          overlay.style.display = 'flex';
          const panel = document.getElementById('panel');
          panel.innerHTML = panelHTML('paused');
          const resumeBtn = document.getElementById('resumeBtn');
          const restartBtn = document.getElementById('restartBtn');
          if (resumeBtn) resumeBtn.addEventListener('pointerdown', (ev) => { ev.preventDefault(); resumeGame(); }, { passive: false });
          if (restartBtn) restartBtn.addEventListener('pointerdown', (ev) => {
            ev.preventDefault();
            if (!state.running || state.gameOver) start();
          }, { passive: false });
          sfxPlay.pause();
        }

        function resumeGame() {
          if (!state.paused) return;
          state.paused = false;
          overlay.style.display = 'none';
          document.getElementById('panel').innerHTML = panelHTML('running');
          audio.resume();
          sfxPlay.resume();
        }

        function panelHTML(mode) {
          if (mode === 'gameover') {
            return `
              <div class="title">ドリームリセット！</div>
              <div class="subtitle">スコア: ${state.score}</div>
              <div class="small" style="margin-bottom:8px">最高記録: ${state.best}</div>
              <div class="btn" id="restartBtn">二度寝する？ (Enter/Space)</div>
              <div class="small">操作: ← → または A D</div>
            `;
          }
          if (mode === 'paused') {
            return `
              <div class="title">一時停止</div>
              <div class="subtitle">スコア: ${state.score} ／ 糖: ${state.sugars}</div>
              <div class="btn" id="resumeBtn">再開 (Esc)</div>
              <div class="btn" id="restartBtn" style="margin-left:8px">リスタート</div>
              <div class="small">Esc で再開。Enter/Space でリスタート</div>
            `;
          }
          // running/ready placeholder
          return `
            <div class="title">グルコースマンの落ちゲー</div>
            <div class="subtitle">下から上へせり上がる足場を乗り継ぎながら、できるだけ下へ降り続けよう！</div>
            <div>操作: <span class="key">←</span> <span class="key">→</span> または <span class="key">A</span> <span class="key">D</span> ／ ジャンプ: <span class="key">↑</span> <span class="key">W</span> <span class="key">Space</span></div>
            <div class="small">スマホ: 画面下の ← ⤴︎ → ボタン</div>
            <div class="small">フィーバー中は 2 段ジャンプが可能！</div>
            <div class="small">落ち続けて距離を稼ぎ、足場を踏み外して画面下に落ちるとゲームオーバー</div>
            <div class="small" style="margin-top:8px">最高記録: ${state.best}</div>
            <div class="btn" id="startBtn">ゲーム開始 (Enter/Space)</div>
          `;
        }

        // Game loop
        let last = performance.now();
        function tick(now) {
          const rawDt = Math.min(0.033, (now - last) / 1000);
          last = now;
          // スローモーション適用（フェーズ3突入時など）
          if (timeCtl.active) {
            timeCtl.t += rawDt;
            const p = Math.max(0, Math.min(1, timeCtl.t / Math.max(0.001, timeCtl.duration)));
            timeCtl.factor = timeCtl.from + (timeCtl.target - timeCtl.from) * p;
            if (p >= 1) { timeCtl.active = false; timeCtl.factor = timeCtl.target; }
          }
          const dt = rawDt * Math.max(0.05, timeCtl.factor);

          if (state.running && !state.paused) update(dt);
          // FPS計測（1.5秒ごとに評価してblurを縮小/無効化）
          try {
            PERF.frames += 1; PERF.time += rawDt; PERF.evalT += rawDt;
            if (PERF.evalT >= 1.5) {
              const fps = (PERF.frames / Math.max(0.001, PERF.time));
              let s = 1;
              if (fps < 35) s = 0; else if (fps < 50) s = 0.5;
              if (s !== PERF.blurScale) { PERF.blurScale = s; try { if (DEV && DEV.dev) console.log('[BG] blurScale', s, 'fps', fps.toFixed(1)); } catch(_){} }
              PERF.frames = 0; PERF.time = 0; PERF.evalT = 0;
            }
          } catch(_){}
          draw();
          requestAnimationFrame(tick);
        }
        requestAnimationFrame(tick);

        // 初期復元の試行（存在すれば自動再開）
        tryRestore();

        function update(dt) {
          // プレイヤースケール補間（足元と中心を維持して見た目と当たり判定を一致）
          if (player.scale !== player.scaleTarget) {
            player.scaleLerpT = Math.min(player.scaleLerpDur, player.scaleLerpT + dt);
            const tt = (player.scaleLerpDur > 0) ? (player.scaleLerpT / player.scaleLerpDur) : 1.0;
            const t = easeInOut(Math.max(0, Math.min(1, tt)));
            const newScale = lerp(player.scaleStart, player.scaleTarget, t);
            if (Math.abs(newScale - player.scale) > 1e-4) {
              const oldW = player.w, oldH = player.h;
              const footY = player.y + oldH;
              const cx = player.x + oldW / 2;
              player.scale = newScale;
              player.w = Math.round((player.baseW) * newScale);
              player.h = Math.round((player.baseH) * newScale);
              player.y = footY - player.h;
              player.x = Math.round(cx - player.w / 2);
            }
          }
          // 初着地グレース更新（開始/続き直後）
          if (state.allowFirstLand) {
            if (state.firstLandingWait) {
              state.firstLandingWait = false;
            } else {
              if (platforms && platforms.length > 0 && !player.onGround) {
                // プレイヤーのヒットボックス（0.75倍、左右中央寄せ、底面はスプライト下端に揃える）
                const hitW = player.w * 0.75;
                const hitLeftP = player.x + (player.w - hitW) * 0.5;
                const hitRightP = hitLeftP + hitW;
                const footY = player.y + player.h; // 底面は据え置き
                let best = null, bestDy = 9999;
                for (const pf of platforms) {
                  if (pf.safe) continue;
                  const hitW = pf.w * 0.8;
                  const hitX = pf.x + (pf.w - hitW) * 0.5;
                  const hitLeft = hitX, hitRight = hitX + hitW;
                  const overlapX = (hitRightP) > (hitLeft - 1) && (hitLeftP) < (hitRight + 1);
                  if (!overlapX) continue;
                  const dy = pf.y - footY;
                  if (dy >= 0 && dy <= 10 && dy < bestDy) { bestDy = dy; best = pf; }
                }
                if (best) {
                  player.y = best.y - player.h;
                  player.vy = 0;
                  player.onGround = true;
                  player.groundId = best.id;
                  state.allowFirstLand = false;
                }
              }
            }
            state.firstLandingTimer = Math.max(0, state.firstLandingTimer - dt);
            if (state.firstLandingTimer === 0) state.allowFirstLand = false;
          }
          state.time += dt;
          // オートセーブ（2.5秒ごと、プレイ中のみ）
          if (!window.__gmAutosave) window.__gmAutosave = { t: 0 };
          window.__gmAutosave.t += dt;
          if (window.__gmAutosave.t >= 2.5 && state.running && !state.paused && !state.gameOver) {
            window.__gmAutosave.t = 0;
            try {
              const save = serializeSave();
              localStorage.setItem('glucoseman_autosave', JSON.stringify(save));
            } catch(_){}
          }

          // 進行中のみ：誤リロード確認（beforeunload）フラグ管理
          if (state.running && !state.paused && !state.gameOver) {
            if (!window.__gmUnloadGuard) {
              window.addEventListener('beforeunload', window.__gmUnloadGuard = (e) => {
                e.preventDefault(); e.returnValue = '';
              });
            }
          } else if (window.__gmUnloadGuard) {
            window.removeEventListener('beforeunload', window.__gmUnloadGuard);
            window.__gmUnloadGuard = null;
          }
          
          // フェーズ制御の更新
          updatePhase();
          // 背景サブフェーズ（BGM時間）
          updateBgVisual(dt);
          
          // フェーズ変更演出の更新
          if (phaseTransition.active) {
            phaseTransition.timer += dt;
            if (phaseTransition.timer >= phaseTransition.duration) {
              phaseTransition.active = false;
            }
          }
          
          // 画面揺れの更新
          if (screenShake.active) {
            screenShake.timer += dt;
            if (screenShake.timer >= screenShake.duration) {
              screenShake.active = false;
              screenShake.intensity = 0;
            }
          }
          
          // 難易度制御：フェーズ中のベース速度
          phaseTimer += dt;
          const p = clamp01(phaseTimer / Math.max(0.001, phaseLenSec));
          let f = phaseSpeedProfile.start;
          // フェーズ1〜3：直線的に開始→終了へ（波や上下動なし）
          // フェーズ4：前半は加速、後半は最大帯に固定
          const linear = lerp(phaseSpeedProfile.start, phaseSpeedProfile.end, p);
          f = linear;
          // フェーズ加速係数を1.20倍（曲線形状は維持）
          f *= 1.20;
          if (currentPhase === 'final' && p >= 0.5) {
            f = phaseSpeedProfile.end;
          }
          speedCtl.factor = f;
          // 速度変動：フェーズ4後半のみサイン波で波打つ（±FINAL_WAVE_AMP）。他フェーズは変動なし。
          let mod = 1.0;
          if (currentPhase === 'final' && p >= 0.5) {
            speedOsc.t += dt;
            const per = Math.max(0.001, phasePeriod('final'));
            const sine = Math.sin((speedOsc.t / per) * Math.PI * 2);
            const raw = 1 + FINAL_WAVE_AMP * sine;
            const smoothRate = 6; // 時定数 ≈ 1/6s
            speedOsc.raw = raw;
            speedOsc.mod += (raw - speedOsc.mod) * Math.min(1, dt * smoothRate);
            mod = speedOsc.mod;
          } else {
            // 変動なし
            speedOsc.mod += (1 - speedOsc.mod) * Math.min(1, dt * 6);
            mod = 1.0;
          }
          // 全体スクロール速度を1.30倍
          world.scrollSpeed = speedCtl.base * speedCtl.factor * mod * 1.30;
          // 深度は常時進行（赤いバー上でも進む）
          state.depth += world.scrollSpeed * dt * 0.12; // px -> meters scale
          // 観賞モード（未アクティブのまま）で一定深度に到達したらエンディング
          if (!state.activated && state.depth >= state.passiveEndDepth) {
            gameOver();
          }

          // 背景ティッカーとポップアップ更新（UIより背面）: フェーズ1/2/3
          if (currentPhase === 'phase1' || currentPhase === 'phase2' || currentPhase === 'phase3') {
            BG.tickerX -= BG.tickerSpeed * dt;
          }
          // フェーズ2テロップのスクロール更新（左→右）
          if (BG.p2Active) {
            BG.p2X += BG.p2Speed * dt;
          }
          
          if (currentPhase === 'phase1' || currentPhase === 'phase2' || currentPhase === 'phase3') {
            // ポップアップ生成（約2.2～4.0秒間隔）
            BG.spawnTimer -= dt;
            if (BG.spawnTimer <= 0) {
              BG.spawnTimer = 2.2 + Math.random() * 1.8;
              const text = nextWordForPhase(currentPhase);
              const W = canvas.clientWidth, H = canvas.clientHeight;
              // 中央寄りに限定（X:20〜80%、Y:30〜70%）
              const L = 0.2 * W, R = 0.8 * W;
              const T = 0.3 * H, B = 0.7 * H;
              // フォントサイズをはみ出さない範囲で自動調整
              ctx.save();
              let fs = 36;
              if (currentPhase === 'phase2') fs = 34;
              const face = 'system-ui, -apple-system, sans-serif';
              let wText = Infinity;
              const maxWidth = Math.max(40, Math.floor((R - L) - 24));
              while (fs > 14) {
                ctx.font = `600 ${fs}px ${face}`;
                wText = Math.ceil(ctx.measureText(text).width);
                if (wText <= maxWidth) break;
                fs -= 2;
              }
              // 配置: 左端〜右端-テキスト幅の範囲に収める
              const minX = L;
              const maxX = Math.max(L, R - wText);
              const x = minX + Math.random() * Math.max(1, (maxX - minX));
              const minY = Math.max(T + fs, T + 8);
              const maxY = Math.max(minY, B - 8);
              const y = minY + Math.random() * Math.max(1, (maxY - minY));
              ctx.restore();
              BG.popups.push({
                x,
                y,
                vx: (currentPhase==='phase3' ? (Math.random()*10-5) : (Math.random()*20-10)),
                vy: -20 - Math.random() * 20,
                life: 0,
                ttl: 2.5 + Math.random() * 1.2,
                text,
                fs,
              });
            }
            for (const p of BG.popups) {
              p.life += dt;
              p.x += p.vx * dt;
              p.y += p.vy * dt;
              p.vx *= (1 - Math.min(1, dt * 1.5));
              p.vy += 10 * dt; // ほんのり重力
            }
            BG.popups = BG.popups.filter(p => p.life < p.ttl);
          } else {
            // フェーズ1/3以外では即時クリア（再出現防止）
            BG.popups.length = 0;
          }

          // 入力（横移動）：左右同時押し時は最後に押した方向を優先
          let dir = 0;
          const L = keys.has('left');
          const R = keys.has('right');
          if (L && R) {
            dir = (inputOrder.left >= inputOrder.right) ? -1 : 1;
          } else if (L) {
            dir = -1;
          } else if (R) {
            dir = 1;
          }
          player.vx = dir * player.speed;
          player.x += player.vx * dt;

          // Wrap horizontally for flow
          const W = canvas.clientWidth, H = canvas.clientHeight;
          if (player.x < -player.w) player.x = W;
          if (player.x > W) player.x = -player.w;

          // ジャンプ猶予のタイマー更新
          if (player.onGround) control.coyote = JUMP_COYOTE; else control.coyote = Math.max(0, control.coyote - dt);
          control.jumpBuf = Math.max(0, control.jumpBuf - dt);

          // 動く足場の更新（当たり判定前に反映）
          // サイン波で左右にスイング。prevXに前フレーム位置を保持。
          for (const pf of platforms) {
            if (pf && pf.sway && !pf.safe) {
              const s = pf.sway;
              s.t += s.omega * dt;
              const nx = s.center + Math.sin(s.t) * s.amp;
              s.prevX = pf.x;
              pf.x = Math.round(nx);
            }
          }

          // 先にバッファ/コヨーテ/フィーバー2段ジャンプを適用
          if (control.jumpBuf > 0) {
            let canJump = (player.onGround || control.coyote > 0);
            let usedAir = false;
            if (!canJump && state.fever && player.airJumpsLeft > 0) {
              // 空中での2段ジャンプ（フィーバー限定）
              usedAir = true;
              player.airJumpsLeft -= 1;
              canJump = true;
            }
            if (canJump) {
              player.vy = -world.jumpSpeed;
              player.onGround = false;
              player.groundId = null;
              control.jumpBuf = 0;
              sfxPlay.jump();
              anim.jumpKick = usedAir ? 1.2 : 1; // 2段時は少し強め
              if (usedAir) {
                // スピン開始（約1回転、徐々に減衰）
                anim.spinTime = 0.38;
                anim.spinVel = 18; // rad/s おおよそ 18*0.38 ≒ 6.8rad ≒ 1.08回転
              }
            }
          }

          // 重力（縦移動）をサブステップで解決して貫通を防ぐ
          const wasOnGroundBefore = player.onGround;
          let landedThisFrame = false;
          let landedOnSafe = false;
          let remain = dt;
          const maxStep = 1 / 240; // 240Hzで分割
          while (remain > 0) {
            const step = Math.min(maxStep, remain);
            const prevY = player.y;
            player.vy = Math.min(world.maxFall, player.vy + world.gravity * step);
            player.y += player.vy * step;

            // 当たり判定（各サブステップ）
            const prevBottom = prevY + player.h;
            const currBottom = player.y + player.h;
            const prevTop = prevY;
            const currTop = player.y;
            player.onGround = false;
            if (player.vy >= 0) {
              for (const pf of platforms) {
                // 未アクティブ中に赤バー上にいる間は、通常足場との接触を無効化
                if (!state.allowFirstLand && !state.activated && player.groundId === state.safePlatformId && !pf.safe) continue;
                // 上端すり抜けは、アクティブ化前の初着地の妨げにならないよう未アクティブ中は無効化
                if (state.activated && pf.y <= DETACH_AT_TOP && !pf.safe) continue; // 赤いバー以外は上端ですり抜け（アクティブ後のみ）
                // 縮小判定（幅80%、高さ50%）
                const hitW = pf.w * 0.8;
                const hitH = pf.h * 0.5;
                const hitX = pf.x + (pf.w - hitW) * 0.5;
                const hitY = pf.y + (pf.h - hitH) * 0.5;
                const hitLeft = hitX, hitRight = hitX + hitW, hitTop = hitY;
                // プレイヤーのヒットボックスは幅0.75倍（左右中央寄せ）
                const pHitW = player.w * 0.75;
                const pHitL = player.x + (player.w - pHitW) * 0.5;
                const pHitR = pHitL + pHitW;
                const overlapX = (pHitR) > (hitLeft - 1) && (pHitL) < (hitRight + 1);
                if (!overlapX) continue;
                const crossTop = (prevBottom <= hitTop && currBottom >= hitTop);
                const withinTol = (currBottom >= hitTop && currBottom <= hitTop + LAND_TOL);
                if (crossTop || withinTol) {
                  player.y = hitTop - player.h;
                  player.vy = 0;
                  player.onGround = true;
                  player.groundId = pf.id;
                  landedThisFrame = landedThisFrame || !wasOnGroundBefore;
                  landedOnSafe = !!pf.safe;
                  break;
                }
              }
            } else {
              // 上向き（ジャンプ上昇中）の頭ぶつかり判定は赤いバーのみ有効（すり抜けない）
              for (const pf of platforms) {
                if (!pf.safe) continue; // 赤いバー以外は上昇時すり抜け
                const pHitW = player.w * 0.75;
                const pHitL = player.x + (player.w - pHitW) * 0.5;
                const pHitR = pHitL + pHitW;
                const overlapX = (pHitR) > (pf.x - 1) && (pHitL) < (pf.x + pf.w + 1);
                if (!overlapX) continue;
                const pfBottom = pf.y + pf.h;
                const hitBottom = (prevTop >= pfBottom && currTop <= pfBottom);
                if (hitBottom) {
                  player.y = pfBottom; // 下に押し戻す
                  player.vy = 0;
                  break;
                }
              }
            }
            remain -= step;
          }
          // 赤バー（最初の足場）から離れたら自動で消去を開始
          if (state.safePlatformId != null && !state.leftSafe) {
            if (player.groundId !== state.safePlatformId) {
              state.leftSafe = true;
              state.safeFading = true; // 既存のフェード処理で消す
            }
          }
          if (landedThisFrame) {
            anim.landKick = 1; // 着地つぶれ
            // フィーバー中は2段ジャンプをリチャージ
            player.airJumpsLeft = state.fever ? 1 : 0;
            const gpf = platforms.find(p => p.id === player.groundId);
            if (gpf) {
              // 通常足場は着地から1.5秒で消える（最後0.5秒は点滅）
              if (!gpf.safe && gpf.decayT == null) gpf.decayT = 0;
              let firstOnThis = false;
              // 未アクティブ → 非セーフ初着地でアクティブ化、赤バーをフェードアウト
              if (!state.activated && !gpf.safe) {
                state.activated = true;
                state.leftSafe = true;
                state.safeFading = true;
                // スコア加点：未踏の足場のみ、フェーズ別の基本点
                if (!state.scoredPids.has(gpf.id)) {
                  const add = scoreForCurrentPhase();
                  state.score += add;
                  state.scoredPids.add(gpf.id);
                  popups.push({ x: player.x + player.w/2, y: player.y - 16, vx: 0, vy: -24, life: 0, text: `+${add}`, color: world.hudColor });
                  firstOnThis = true;
                }
                state.lastScorePid = gpf.id;
              } else if (state.activated && !gpf.safe) {
                // アクティブ後：未踏の足場に初着地でのみ加点（同一生成IDには二度と加点しない）
                if (!state.scoredPids.has(gpf.id)) {
                  const add = scoreForCurrentPhase();
                  state.score += add;
                  state.scoredPids.add(gpf.id);
                  popups.push({ x: player.x + player.w/2, y: player.y - 16, vx: 0, vy: -24, life: 0, text: `+${add}`, color: world.hudColor });
                  firstOnThis = true;
                }
                state.lastScorePid = gpf.id;
              }
              // SFX：最初の足場（safe=true）は常に無音。
              // 非セーフ足場の初着地のみ「チャッ」を鳴らす。それ以外の着地は従来のlandを鳴らす。
              if (!gpf.safe) {
                if (firstOnThis) sfxPlay.firstLand();
                else sfxPlay.land();
              }
            }
          }

          // アニメパラメータ更新
          const targetAir = player.onGround ? 0 : 1;
          anim.air += (targetAir - anim.air) * Math.min(1, dt * 10);
          anim.jumpKick = Math.max(0, anim.jumpKick - dt * 6);
          anim.landKick = Math.max(0, anim.landKick - dt * 6);
          // squash: ジャンプ時は縦伸び、着地時はつぶれ
          const baseSquash = 1 + anim.landKick * 0.18 - anim.jumpKick * 0.12;
          anim.squash += (baseSquash - anim.squash) * Math.min(1, dt * 10);
          // tilt: 横移動で少し傾く
          const targetTilt = (player.vx / Math.max(1, player.speed)) * 0.18;
          anim.tilt += (targetTilt - anim.tilt) * Math.min(1, dt * 8);
          anim.leafPhase += dt * (4 + 3 * anim.air + 3 * anim.jumpKick);
          // スピン減衰
          if (anim.spinTime > 0) {
            anim.spin += anim.spinVel * dt;
            anim.spinVel += (-anim.spinVel) * Math.min(1, dt * 6);
            anim.spinTime = Math.max(0, anim.spinTime - dt);
          } else {
            anim.spin = 0;
            anim.spinVel = 0;
          }

          // 地面にいる間は足場に粘着（微小誤差で抜けない）
          if (player.onGround && player.groundId != null) {
            const pf = platforms.find(p => p.id === player.groundId);
            if (pf) {
              const hitW = pf.w * 0.8;
              const hitH = pf.h * 0.5;
              const hitX = pf.x + (pf.w - hitW) * 0.5;
              const hitY = pf.y + (pf.h - hitH) * 0.5;
              const hitLeft = hitX, hitRight = hitX + hitW, hitTop = hitY;
              if (pf.y > DETACH_AT_TOP && (player.x + player.w) > (hitLeft - 1) && player.x < (hitRight + 1)) {
                player.y = hitTop - player.h;
                player.vy = 0;
              } else {
                player.onGround = false;
                player.groundId = null;
              }
            } else {
              player.onGround = false;
              player.groundId = null;
              // 動く足場に乗っている場合、足場の移動量に合わせて少し運ぶ
              if (pf.sway && typeof pf.sway.prevX === 'number') {
                const dx = pf.x - pf.sway.prevX;
                if (Math.abs(dx) > 0) {
                  player.x += dx;
                }
              }
            }
          }

          // 立ち続け判定用：足場を離れたらタイマーをリセット
          if (!player.onGround && state.lastGroundId != null) {
            const last = platforms.find(p => p.id === state.lastGroundId);
            if (last && !last.safe) last.stayT = 0;
            state.lastGroundId = null;
          } else if (player.onGround) {
            state.lastGroundId = player.groundId;
          }


          // ワールドの自動スクロール（上方向）
          const scroll = world.scrollSpeed * dt;
          player.y -= scroll;
          for (const p of platforms) { if (!p.safe) p.y -= scroll; }
          for (const s of sugars) s.y -= scroll;
          if (state.safeGlow) state.safeGlow.y -= scroll;
          if (state.safeGlow) state.safeGlow.y -= scroll;

          // 通常足場の消滅タイマー：着地からPLATFORM_DECAY_LIMIT秒で消える
          const DECAY_LIMIT = PLATFORM_DECAY_LIMIT;
          for (const p of platforms) {
            if (!p.safe && p.decayT != null) p.decayT += dt;
          }
          // 消滅処理
          for (const p of platforms.slice()) {
            if (!p.safe && p.decayT != null && p.decayT >= DECAY_LIMIT) {
              if (player.groundId === p.id) { player.onGround = false; player.groundId = null; }
              platforms = platforms.filter(q => q.id !== p.id);
            }
          }
          // 天蓋との接触は無効化（直線/ドームなし）

          // 足場の生成/掃除
          // 画面上に消えたものを削除。ただし現在接地中の足場は保持して勝手に消えないようにする
          // セーフ足場のフェード処理と削除
          if (state.safeFading && state.safePlatformId != null) {
            state.safeFadeT = Math.min(1, state.safeFadeT + dt / Math.max(0.001, state.safeFadeDuration));
            if (state.safeFadeT >= 1) {
              const sp = platforms.find(p => p.id === state.safePlatformId);
              if (sp) {
                state.safeGlow = { x: sp.x, y: sp.y, w: sp.w, h: sp.h, t: 0.8 };
              }
              platforms = platforms.filter(p => p.id !== state.safePlatformId);
              state.safePlatformId = null; // 完全に消去
              state.safeFading = false;
            }
          }
          // 画面上端を超えた足場は即削除（接地中でも削除して落とす）
          for (const p of platforms.slice()) {
            if ((p.y + p.h) <= 0) {
              if (player.groundId === p.id) { player.onGround = false; player.groundId = null; }
              platforms = platforms.filter(q => q.id !== p.id);
            }
          }
          let maxY = platforms.length ? Math.max(...platforms.map(p => p.y)) : -40;
          // 足場の同時存在数を抑えつつ、時間間隔で生成
          pfSpawnTimer += dt;
          const cfg = spawnConfigForPhase(currentPhase);
          const nonSafeCount = platforms.reduce((n,p)=>n + (p.safe?0:1), 0);
          if (nonSafeCount < cfg.limit && pfSpawnTimer >= pfNextDelay) {
            pfSpawnTimer = 0;
            pfNextDelay = randf(cfg.min, cfg.max);
            const gapMin = Math.floor(world.platformGapMin * world.platformGapScale);
            const gapMax = Math.floor(world.platformGapMax * world.platformGapScale);
            if (maxY < H + 100) maxY = Math.max(maxY, H + 40);
            maxY += rand(gapMin, gapMax);
            platforms.push(makePlatform(maxY));
          }
          // 可視最低数の保証（3未満になったら即時補充）
          const visibleNonSafe = platforms.reduce((n,p)=> n + (!p.safe && (p.y + p.h) > 0 && p.y < H ? 1 : 0), 0);
          if (visibleNonSafe < MIN_VISIBLE_PLATFORMS) {
            const need = MIN_VISIBLE_PLATFORMS - visibleNonSafe;
            const gapMin = Math.floor(world.platformGapMin * world.platformGapScale);
            const gapMax = Math.floor(world.platformGapMax * world.platformGapScale);
            let added = 0;
            while (added < need && added < 4) {
              if (maxY < H + 100) maxY = Math.max(maxY, H + 40);
              maxY += rand(gapMin, gapMax);
              platforms.push(makePlatform(maxY));
              added++;
            }
          }

          // Collect sugars
          for (const s of sugars) {
            if (!s.alive) continue;
            const sx = s.x, sy = s.y, r = s.r;
            // AABB vs circle with player's hitbox (0.75x, bottom-aligned)
            const pw = player.w * 0.75;
            const ph = player.h * 0.75;
            const px = player.x + (player.w - pw) * 0.5;
            const py = player.y + (player.h - ph); // bottom-aligned
            const nx = Math.max(px, Math.min(sx, px + pw));
            const ny = Math.max(py, Math.min(sy, py + ph));
            const dx = sx - nx, dy = sy - ny;
            if (dx*dx + dy*dy <= (r*r)) {
              s.alive = false;
              state.sugars += 1;
              // コンボ処理
              if (!state.fever) {
                // コンボ（スコア用）は継続
                state.comboTime = state.comboWindow;
                const prevMult = state.comboMult;
                state.comboCount += 1;
                state.comboMult = Math.min(5, 1 + Math.floor(state.comboCount / 3));
                if (state.comboMult > prevMult) {
                  sfxPlay.combo();
                  popups.push({x: sx, y: sy, vx: 0, vy: -18, life: 0, text: `x${state.comboMult}!`, color: '#a8ffcc'});
                }
                // 5個取得でスーパー（フィーバー）発動
                state.pickStreak += 1;
                if (state.pickStreak >= state.feverNeed) {
                  startFever();
                  state.pickStreak = 0;
                }
              } else {
                // スーパー中は時間延長なし（一定時間固定）
              }
              // スコアは足場着地でのみ加算。糖はカウントのみ。
              sfxPlay.pick();
              popups.push({x: sx, y: sy, vx: (Math.random()*14-7), vy: -22, life: 0, text: `+糖` , color: '#ffe58a'});
            }
          }
          // Cleanup sugars that went off screen or collected
          // 生成直後に画面外（下側）にある糖が即削除されないよう、余裕を広く取る
          sugars = sugars.filter(s => s.alive && s.y + 12 > -40 && s.y < H + 800);

          // セーフ残光の寿命
          if (state.safeGlow) {
            state.safeGlow.t -= dt;
            if (state.safeGlow.t <= 0) state.safeGlow = null;
          }

          // コンボ・フィーバー時間経過
          if (!state.fever) {
            state.comboTime = Math.max(0, state.comboTime - dt);
            if (state.comboTime === 0 && state.comboCount > 0) {
              state.comboCount = 0;
              state.comboMult = 1;
            }
          } else {
            state.feverTime -= dt;
            if (state.feverTime <= 0) {
              state.fever = false;
              state.comboCount = 0;
              state.comboMult = 1;
              // フィーバー終了と共に空中での2段ジャンプ権を削除
              if (!player.onGround) player.airJumpsLeft = 0;
              state.pickStreak = 0;
            }
          }

          // ポップアップ更新
          for (const p of popups) {
            p.life += dt;
            p.x += p.vx * dt;
            p.y += p.vy * dt;
            p.vy -= 30 * dt;
          }
          popups = popups.filter(p => p.life < 1.0);

          // Game over: fell off bottom of screen
          if (player.y > H) {
            gameOver();
          }
        }

// 天蓋当たり判定は廃止

        function gameOver() {
          state.running = false;
          state.gameOver = true;
          // オートセーブ停止（次回起動時に続きからにしない）
          try {
            const raw = localStorage.getItem('glucoseman_autosave');
            if (raw) {
              const data = JSON.parse(raw);
              if (data) { data.active = false; localStorage.setItem('glucoseman_autosave', JSON.stringify(data)); }
            }
          } catch(_){}
          // BGM制御：デバウンス付きで即停止→曲頭へ
          BGM.onGameOver();
          state.best = Math.max(state.best, state.score);
          localStorage.setItem('glucoseman_best', String(state.best));
          // HUDはスコアとフェーズ名のみを小さく表示
          const phaseLabelsHUD = {
            phase1: '現世のうつしよ ― 光の回廊',
            phase2: '第二階層 ― 揺らぎの明晰夢',
            phase3: '第三階層 ― 時間が伸びる世界',
            final:  '夢の楽園 ― 夢の楽園'
          };
          hud.textContent = `フェーズ: ${phaseLabelsHUD[currentPhase]||currentPhase} ／ スコア: ${state.score}`;
          overlay.style.display = 'flex';
          const panel = document.getElementById('panel');
          panel.innerHTML = panelHTML('gameover');
          const restartBtn = document.getElementById('restartBtn');
          if (restartBtn) restartBtn.addEventListener('pointerdown', (ev) => {
            ev.preventDefault();
            if (!state.running || state.gameOver) start();
          }, { passive: false });
          sfxPlay.over();
        }

        function draw() {
          const W = canvas.clientWidth, H = canvas.clientHeight;
          // 前フレームの描画内容を完全クリア（古い文字や残像を確実に消す）
          ctx.clearRect(0, 0, W, H);
          
          // 画面揺れ適用
          ctx.save();
          if (screenShake.active) {
            const progress = 1 - (screenShake.timer / screenShake.duration);
            const intensity = screenShake.intensity * progress;
            const shakeX = (Math.random() - 0.5) * intensity;
            const shakeY = (Math.random() - 0.5) * intensity;
            ctx.translate(shakeX, shakeY);
          }
          
          // === 背景描画（サブフェーズ対応・スライド＋フェード） ===
          const drawBgStepLayer = (step, alpha=1, offsetY=0) => {
            const idx = Math.max(1, Math.min(7, step)) - 1;
            const img = BG_STEP_IMAGES[idx];
            const ready = !!(img && img.complete && (img.naturalWidth || 0) > 0);
            ctx.save();
            ctx.translate(0, offsetY);
            ctx.globalAlpha *= alpha;
            if (ready) {
              ctx.drawImage(img, 0, 0, W, H);
            } else {
              const grad = ctx.createLinearGradient(0, 0, 0, H);
              grad.addColorStop(0, '#bfe1ff');
              grad.addColorStop(1, '#ffffff');
              ctx.fillStyle = grad;
              ctx.fillRect(0, 0, W, H);
            }
            ctx.restore();
          };

          if (bgVisual.trans && bgVisual.trans.active) {
            // 同時スクロール（一定速度・ぼかしなし）
            const p = Math.max(0, Math.min(1, bgVisual.trans.t / Math.max(0.001, bgVisual.trans.dur)));
            const yOld = Math.floor(-p * H);     // 0 → -H
            const yNew = Math.floor(H - p * H);  // H → 0
            drawBgStepLayer(bgVisual.trans.from.step, 1.0, yOld);
            drawBgStepLayer(bgVisual.trans.to.step, 1.0, yNew);
          } else {
            drawBgStepLayer(bgVisual.step, 1.0, 0);
          }

          // 天蓋描画は無効化（直線/ドームなし）

          // Subtle grid for depth
          ctx.save();
          ctx.globalAlpha = 0.12;
          ctx.strokeStyle = '#7a8bbb';
          const step = 40;
          ctx.beginPath();
          for (let x = 0; x < W; x += step) { ctx.moveTo(x, 0); ctx.lineTo(x, H); }
          for (let y = 0; y < H; y += step) { ctx.moveTo(0, y); ctx.lineTo(W, y); }
          ctx.stroke();
          ctx.restore();

          // フェーズ2：ニュース番組風テロップ
          // その他：通常の背景ティッカー（ランダム）
          if (false && BG.whisperActive && BG.whisperAlpha > 0) {
            // 旧：囁きテキストは無効化
            // 残置（将来の切替用）
            
          } else if (currentPhase === 'phase2' && BG.p2Active) {
            // フェーズ2専用：半透明の黒帯 + 白文字、左→右にスクロール
            const barH = 64;
            const barY = H - barH - 6;
            ctx.save();
            // 帯
            ctx.globalAlpha = 0.6;
            ctx.fillStyle = 'rgba(0,0,0,0.75)';
            ctx.fillRect(0, barY, W, barH);
            ctx.globalAlpha = 1;
            // 文字
            ctx.font = 'bold 28px system-ui, -apple-system, sans-serif';
            ctx.fillStyle = '#ffffff';
            ctx.textBaseline = 'alphabetic';
            const msg = BG.p2Messages[BG.p2Index] || '';
            const wText = ctx.measureText(msg).width;
            // 初回フレームで左外から開始位置を調整
            if (BG.p2X < -W*2) {
              BG.p2X = -wText - BG.p2Gap;
            }
            // テキスト描画（左→右）
            const tx = Math.floor(BG.p2X);
            const ty = Math.floor(barY + barH - 14);
            ctx.fillText(msg, tx, ty);
            // 右端を通過したら次メッセージへ
            if (BG.p2X > W + BG.p2Gap) {
              BG.p2Index = (BG.p2Index + 1) % BG.p2Messages.length;
              const nextMsg = BG.p2Messages[BG.p2Index] || '';
              const wNext = ctx.measureText(nextMsg).width;
              BG.p2X = -wNext - BG.p2Gap;
            }
            // 上縁に薄い線
            ctx.globalAlpha = 0.2;
            ctx.fillStyle = '#ffffff';
            ctx.fillRect(0, barY, W, 1);
            ctx.restore();
          } else if (currentPhase === 'phase1') {
            // 通常の背景ティッカー
            ctx.save();
            const barH = 64;
            const barY = H - barH - 6;
            ctx.globalAlpha = 0.55;
            ctx.fillStyle = 'rgba(20,24,40,0.65)';
            ctx.fillRect(0, barY, W, barH);
            ctx.globalAlpha = 1;
            ctx.font = 'bold 32px system-ui, -apple-system, sans-serif';
            ctx.fillStyle = '#a8b4ff';
            // テキストのループ描画
            const text = BG.tickerText;
            const wText = ctx.measureText(text).width;
            let tx = BG.tickerX % (wText || 1);
            if (tx > 0) tx -= wText;
            for (let i = -1; i < 3; i++) {
              ctx.fillText(text, Math.floor(tx + i * wText + 12), Math.floor(barY + barH - 8));
            }
            // 上縁に薄い線
            ctx.globalAlpha = 0.2;
            ctx.fillStyle = '#b4c3ff';
            ctx.fillRect(0, barY, W, 1);
            ctx.restore();
          }

          // セーフ足場の残光
          if (state.safeGlow && state.safeGlow.t > 0) {
            const g = state.safeGlow;
            const fade = Math.max(0, Math.min(1, g.t / 0.8));
            ctx.save();
            ctx.globalAlpha = 0.28 * fade;
            const lg = ctx.createLinearGradient(g.x, g.y, g.x, g.y + g.h);
            lg.addColorStop(0, 'rgba(204,0,0,0.9)');
            lg.addColorStop(1, 'rgba(204,0,0,0)');
            ctx.fillStyle = lg;
            ctx.fillRect(g.x - 8, g.y - 4, g.w + 16, g.h + 8);
            ctx.restore();
          }

          // 背景ポップアップ（浮遊テキスト）: フェーズ1/2/3
          if (currentPhase === 'phase1' || currentPhase === 'phase2' || currentPhase === 'phase3') {
            for (const p of BG.popups) {
              const fade = Math.max(0, 1 - (p.life / p.ttl));
              ctx.save();
              if (currentPhase === 'phase3') {
                // 可読性改善：淡い白＋低めの透明度（かすかに読める程度）
                ctx.globalAlpha = (0.2 + 0.1 * 0.5) * fade; // ≈ 0.25 * fade
                ctx.fillStyle = '#ffffff';
              } else {
                // フェーズ1は従来通り
                ctx.globalAlpha = 0.65 * fade;
                ctx.fillStyle = '#2c3e66';
              }
              const fs = Math.max(14, Math.min(48, Math.floor(p.fs || 36)));
              ctx.font = `600 ${fs}px system-ui, -apple-system, sans-serif`;
              ctx.fillText(p.text, p.x, p.y);
              ctx.restore();
            }
          }

          // フェーズ背景ティント
          if (world.bgTint !== 'rgba(0,0,0,0.0)') {
            ctx.save();
            ctx.fillStyle = world.bgTint;
            ctx.fillRect(0, 0, W, H);
            ctx.restore();
          }

          // フェーズ変更演出
          if (phaseTransition.active) {
            const progress = phaseTransition.timer / phaseTransition.duration;
            const flash = Math.sin(progress * Math.PI * 4) * (1 - progress);
            ctx.save();
            ctx.globalAlpha = Math.abs(flash) * 0.3;
            ctx.fillStyle = world.hudColor;
            ctx.fillRect(0, 0, W, H);
            ctx.restore();
          }

          // FEVER画面ティント
          if (state.fever) {
            ctx.save();
            const a = 0.14 + 0.06 * Math.sin(state.time * 8);
            const tint = ctx.createLinearGradient(0, 0, 0, H);
            tint.addColorStop(0, `rgba(255,216,120,${a})`);
            tint.addColorStop(1, `rgba(120,255,200,${a*0.75})`);
            ctx.fillStyle = tint;
            ctx.fillRect(0, 0, W, H);
            ctx.restore();
          }

          // Platforms
          for (const p of platforms) {
            if (p.safe) {
              const alpha = (state.safeFading && state.safePlatformId === p.id) ? Math.max(0, 1 - state.safeFadeT) : 1;
              ctx.save();
              ctx.globalAlpha = alpha;
              
              // ベッド画像が読み込まれていれば画像を、そうでなければ赤いバー
              // 赤いバー
              ctx.fillStyle = '#cc0000';
              ctx.fillRect(p.x, p.y, p.w, p.h);
              
              ctx.restore();
              continue;
            }
            // 通常足場の点滅（消滅直前0.5秒）
            const blink = (p.decayT != null && p.decayT >= (PLATFORM_DECAY_LIMIT - 0.5));
            if (blink) {
              const phase = p.decayT - (PLATFORM_DECAY_LIMIT - 0.5);
              const visible = (Math.floor((phase) / 0.1) % 2) === 0; // 0.1秒ごとに交互
              if (!visible) continue; // 非表示フレーム
            }
            const c1 = world.platformColor1;
            const c2 = world.platformColor2;
            const g = ctx.createLinearGradient(p.x, p.y, p.x, p.y + p.h);
            g.addColorStop(0, c1);
            g.addColorStop(1, c2);
            ctx.save();
            // 旧フェードロジックは使用しない
            ctx.fillStyle = g;
            ctx.fillRect(p.x, p.y, p.w, p.h);
            // small glow
            ctx.fillStyle = 'rgba(90,190,255,0.25)';
            ctx.fillRect(p.x, p.y + p.h - 2, p.w, 2);
            ctx.restore();
          }

          // Sugars (collectibles)
          for (const s of sugars) {
            const t = state.time;
            const pulse = 0.6 + 0.4 * Math.sin(t * 6 + s.id);
            const r = s.r * (0.9 + 0.15 * pulse);
            const g = ctx.createRadialGradient(s.x, s.y, 1, s.x, s.y, r*2.2);
            if (state.fever) {
              g.addColorStop(0, 'rgba(255,255,200,0.95)');
              g.addColorStop(1, 'rgba(180,255,200,0)');
            } else {
              g.addColorStop(0, 'rgba(255,240,180,0.9)');
              g.addColorStop(1, 'rgba(255,180,80,0)');
            }
            ctx.fillStyle = g;
            ctx.beginPath(); ctx.arc(s.x, s.y, r*1.6, 0, Math.PI*2); ctx.fill();
            // core
            ctx.fillStyle = state.fever ? '#ffff88' : '#ffd96a';
            ctx.beginPath();
            ctx.moveTo(s.x, s.y - r);
            for (let i = 1; i < 6; i++) {
              const ang = -Math.PI/2 + i * (Math.PI*2/6);
              ctx.lineTo(s.x + Math.cos(ang) * r, s.y + Math.sin(ang) * r);
            }
            ctx.closePath();
            ctx.fill();
            ctx.strokeStyle = state.fever ? 'rgba(220,255,200,0.9)' : 'rgba(255,220,120,0.8)';
            ctx.lineWidth = 1;
            ctx.stroke();
          }

          // Player: グルコースマン（浮遊感は弱め、接地感アップ）
          const drawSink = 4; // 接地感のため全体を少し下げる
          const hover = 1 + Math.sin(state.time * 5) * 0.8; // 浮遊幅を控えめに
          const yAdj = player.y - hover + drawSink;
          drawShadow(player.x, yAdj, player.w, player.h, anim);
          // ずっと目は閉じたまま。ゲームオーバー時のみ開眼
          const sleeping = !state.gameOver;
          drawCharacter(player.x, yAdj, player.w, player.h, anim, sleeping);

          // HUD（左上に小さく、フェーズ名＋スコアのみ）
          hud.style.color = world.hudColor;
          const phaseLabelsHUD2 = {
            phase1: '現世のうつしよ ― 光の回廊',
            phase2: '第二階層 ― 揺らぎの明晰夢',
            phase3: '第三階層 ― 時間が伸びる世界',
            final:  '夢の楽園 ― 夢の楽園'
          };
          hud.textContent = `フェーズ: ${phaseLabelsHUD2[currentPhase]||currentPhase} ／ スコア: ${state.score}`;

          // ポップアップ描画
          for (const p of popups) {
            const alpha = Math.max(0, 1 - p.life / 1.0);
            ctx.save();
            ctx.globalAlpha = alpha;
            ctx.fillStyle = p.color || '#fff';
            ctx.font = 'bold 36px system-ui, sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(p.text, p.x, p.y);
            ctx.restore();
          }
          
          // 背景ティント効果（外部phase-control.jsとの連携用）
          if (typeof tintBackground === 'function') {
            tintBackground(ctx, canvas.width, canvas.height);
          }
          
          // 画面揺れの状態を復元
          ctx.restore();
        }

        function drawCharacter(x, y, w, h, anim, sleeping=false) {
          if (charSpriteReady) return drawSpriteMan(x, y, w, h, anim, sleeping);
          return drawGlucoseMan(x, y, w, h, anim, sleeping);
        }

        function drawSpriteMan(x, y, w, h, anim, sleeping=false) {
          ctx.save();
          const cx = x + w/2;
          const cy = y + h/2;
          const sx = 1 - (anim.squash - 1) * 0.25;
          const sy = anim.squash;
          ctx.translate(cx, cy);
          ctx.rotate(anim.tilt);
          ctx.scale(sx, sy);
          ctx.translate(-cx, -cy);
          // 中央に画像をhに合わせて描画
          const onSafeBar = (!state.activated && state.safePlatformId != null && player.groundId === state.safePlatformId);
          const useSleep = (state.gameOver || onSafeBar) && charSpriteSleepReady;
          const spr = useSleep ? charSpriteSleep : charSprite;
          const iw = spr.naturalWidth || 1;
          const ih = spr.naturalHeight || 1;
          const scale = h / ih;
          const dw = iw * scale;
          const dh = h;
          const dx = cx - dw/2;
          const dy = y;
          ctx.drawImage(spr, dx, dy, dw, dh);
          ctx.restore();

          // 眠り演出（鼻バブル）は重ねて表示
          if (sleeping) {
            const t = (state.time % 2.2) / 2.2;
            const grow = t < 0.7 ? (t / 0.7) : (1 - (t - 0.7) / 0.3);
            const r = 1.5 + 5.0 * Math.max(0, grow);
            const nx = x + w*0.58 + 4 * grow;
            const ny = y + h*0.28 - 10 * grow;
            const a = 0.18 + 0.25 * Math.max(0, grow);
            const bg = ctx.createRadialGradient(nx - r*0.4, ny - r*0.6, r*0.2, nx, ny, r);
            bg.addColorStop(0, `rgba(255,255,255,${a})`);
            bg.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = bg;
            ctx.beginPath(); ctx.arc(nx, ny, r, 0, Math.PI * 2); ctx.fill();
            ctx.strokeStyle = `rgba(255,255,255,${a * 0.9})`;
            ctx.lineWidth = 1;
            ctx.beginPath(); ctx.arc(nx, ny, r, 0, Math.PI * 2); ctx.stroke();
          }
        }

        function drawCanopy(ctx, W, H, t) {
          const pal = (()=>{
            if (currentPhase === 'phase1' || currentPhase === 'phase2') return { s:'rgba(160,210,255,0.95)' };
            if (currentPhase === 'phase3') return { s:'rgba(130,90,180,0.95)' };
            return { s:'rgba(255,220,160,0.92)' };
          })();
          const y = Math.max(1, CANOPY.thickness * 0.5); // 線の半分が見えるように内側へ
          ctx.save();
          ctx.lineWidth = CANOPY.thickness;
          ctx.strokeStyle = pal.s;
          ctx.shadowColor = pal.s; ctx.shadowBlur = 12;
          ctx.beginPath(); ctx.moveTo(0, y); ctx.lineTo(W, y); ctx.stroke();
          ctx.shadowBlur = 0;
          ctx.restore();
        }

        function drawGlucoseMan(x, y, w, h, anim, sleeping=false) {
          ctx.save();
          const cx = x + w / 2;
          const cyAll = y + h / 2;
          // スクワッシュ＆回転
          const sx = 1 - (anim.squash - 1) * 0.5;
          const sy = anim.squash;
          ctx.translate(cx, cyAll);
          // 2段ジャンプ中はスピン回転を合成
          const extraRot = (anim.spinTime > 0 ? anim.spin : 0);
          ctx.rotate(anim.tilt + extraRot);
          ctx.scale(sx, sy);
          ctx.translate(-cx, -cyAll);

          // 頭サイズ（デザイン比率で調整）
          const hr = Math.min(h * design.headRatio, w * (design.headRatio * 1.8));
          const headTop = y;
          const cy = headTop + hr + 2; // 少し下げて配置
          const hg = ctx.createRadialGradient(cx - hr*0.3, cy - hr*0.3, hr*0.4, cx, cy, hr);
          hg.addColorStop(0, palette.head);
          hg.addColorStop(1, palette.headShade);
          ctx.fillStyle = hg;
          ctx.beginPath();
          ctx.arc(cx, cy, hr, 0, Math.PI * 2);
          ctx.fill();

          // 頭の葉っぱ（緑）: 空中でゆらぐ
          ctx.strokeStyle = palette.leafDark;
          ctx.lineWidth = 2;
          ctx.beginPath();
          const sway = Math.sin(anim.leafPhase) * (2 + anim.air * 3);
          ctx.moveTo(cx, cy - hr + 2);
          ctx.quadraticCurveTo(cx - 1 + sway * 0.2, cy - hr - 4, cx + sway * 0.2, cy - hr - 8);
          ctx.stroke();
          ctx.fillStyle = palette.leaf;
          ctx.beginPath();
          ctx.ellipse(cx - 3 + sway, cy - hr - 10, 5, 3, -0.5, 0, Math.PI * 2);
          ctx.fill();
          ctx.beginPath();
          ctx.ellipse(cx + 3 + sway, cy - hr - 8, 5, 3, 0.6, 0, Math.PI * 2);
          ctx.fill();

          // 目：通常は白目＋瞳、眠っている時は閉じ目ライン
          // 目の大きさ・位置（デザイン比率に基づく）
          const eyeOffX = Math.max(6, hr * design.eyeOffsetXR), eyeOffY = -2;
          const eyeR = Math.max(7, hr * design.eyeRadiusRatio);
          if (!sleeping) {
            const look = Math.sin(state.time * 2) * 1.2;
            // 左目
            ctx.fillStyle = palette.eyeWhite;
            ctx.beginPath(); ctx.arc(cx - eyeOffX, cy + eyeOffY, eyeR, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = palette.eyeIris;
            ctx.beginPath(); ctx.arc(cx - eyeOffX + look * 0.6, cy + eyeOffY + 0.6, eyeR * 0.48, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = palette.eyeShine; ctx.beginPath(); ctx.arc(cx - eyeOffX - eyeR*0.22, cy + eyeOffY - eyeR*0.22, Math.max(1.4, eyeR*0.26), 0, Math.PI * 2); ctx.fill();
            // 右目
            ctx.fillStyle = palette.eyeWhite;
            ctx.beginPath(); ctx.arc(cx + eyeOffX, cy + eyeOffY, eyeR, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = palette.eyeIris;
            ctx.beginPath(); ctx.arc(cx + eyeOffX + look * 0.6, cy + eyeOffY + 0.6, eyeR * 0.48, 0, Math.PI * 2); ctx.fill();
            ctx.fillStyle = palette.eyeShine; ctx.beginPath(); ctx.arc(cx + eyeOffX - eyeR*0.22, cy + eyeOffY - eyeR*0.22, Math.max(1.4, eyeR*0.26), 0, Math.PI * 2); ctx.fill();
          } else {
            // 閉じ目（微笑むような弧）
            ctx.strokeStyle = 'rgba(20,16,32,0.9)';
            ctx.lineWidth = Math.max(1.8, hr * 0.07);
            ctx.beginPath(); ctx.arc(cx - eyeOffX, cy + eyeOffY + 1, eyeR * 0.9, 0.15 * Math.PI, 0.85 * Math.PI); ctx.stroke();
            ctx.beginPath(); ctx.arc(cx + eyeOffX, cy + eyeOffY + 1, eyeR * 0.9, 0.15 * Math.PI, 0.85 * Math.PI); ctx.stroke();
          }

          // 眉毛
          const browY = cy + eyeOffY - eyeR - Math.max(2, eyeR * 0.25);
          const browLen = Math.max(6, eyeR * 1.2);
          const browW = Math.max(2, eyeR * 0.35);
          const browColor = palette.eyeIris;
          const ang = sleeping ? 0.05 : 0.22; // 眠い時はフラット、通常は少しハの字
          ctx.strokeStyle = browColor;
          ctx.lineWidth = browW;
          ctx.lineCap = 'round';
          // 左眉
          ctx.save();
          ctx.translate(cx - eyeOffX, browY);
          ctx.rotate(-ang);
          ctx.beginPath(); ctx.moveTo(-browLen/2, 0); ctx.lineTo(browLen/2, 0); ctx.stroke();
          ctx.restore();
          // 右眉
          ctx.save();
          ctx.translate(cx + eyeOffX, browY);
          ctx.rotate(ang);
          ctx.beginPath(); ctx.moveTo(-browLen/2, 0); ctx.lineTo(browLen/2, 0); ctx.stroke();
          ctx.restore();

          // 口（穏やかなスマイル）
          ctx.strokeStyle = 'rgba(20,16,32,0.9)';
          ctx.lineWidth = 1.8;
          ctx.beginPath();
          ctx.arc(cx + 2, cy + 6, 6, 0.2 * Math.PI, 0.8 * Math.PI);
          ctx.stroke();

          // 眠っている時の鼻バブル（透明の小さい風船）
          if (sleeping) {
            const t = (state.time % 2.2) / 2.2; // 0→1 の循環
            const grow = t < 0.7 ? (t / 0.7) : (1 - (t - 0.7) / 0.3); // 0→1→0 の簡易波形
            const r = 1.2 + 4.0 * Math.max(0, grow);
            const dx = 3 + 4 * grow; // 右へ少し移動
            const dy = -2 - 8 * grow; // 上へふわっと
            const nx = cx + 4 + dx;
            const ny = cy + 2 + dy;
            const a = 0.15 + 0.25 * Math.max(0, grow);
            // 透明感のある塗り＋縁
            const bg = ctx.createRadialGradient(nx - r*0.4, ny - r*0.6, r*0.2, nx, ny, r);
            bg.addColorStop(0, `rgba(255,255,255,${a})`);
            bg.addColorStop(1, 'rgba(255,255,255,0)');
            ctx.fillStyle = bg;
            ctx.beginPath(); ctx.arc(nx, ny, r, 0, Math.PI * 2); ctx.fill();
            ctx.strokeStyle = `rgba(255,255,255,${a * 0.9})`;
            ctx.lineWidth = 1;
            ctx.beginPath(); ctx.arc(nx, ny, r, 0, Math.PI * 2); ctx.stroke();
          }

          // 服（上=明るめ、下=暗め）。下半身は今の倍の比率に拡大
          const bodyY = y + 2 * hr;
          const bodyH = Math.max(14, h - 2 * hr); // = 頭と同じ高さ（理想）
          const bodyR = 7;
          // 下半身の比率を従来の2倍に（上限0.9、下限0.1を確保）
          const baseTopRatio = design.shirtRatio;
          const bottomRatio = Math.min(0.9, (1 - baseTopRatio) * 2);
          const topRatio = Math.max(0.1, 1 - bottomRatio);
          // 上半身（シャツ：明るめ）
          const topH = Math.floor(bodyH * topRatio);
          const gTop = ctx.createLinearGradient(x, bodyY, x, bodyY + topH);
          gTop.addColorStop(0, palette.shirtGreen);
          gTop.addColorStop(1, palette.shirtGreenDark);
          ctx.fillStyle = gTop;
          roundRect(ctx, x, bodyY, w, topH, bodyR);
          ctx.fill();
          // 下半身（ズボン：暗め）
          const bottomY = bodyY + topH - Math.min(bodyR, 6); // 少し重ねて角の段差を軽減
          const bottomH = Math.floor(bodyH * bottomRatio) + Math.min(bodyR, 6);
          const gBot = ctx.createLinearGradient(x, bottomY, x, bottomY + bottomH);
          gBot.addColorStop(0, palette.pantsNavy);
          gBot.addColorStop(1, palette.pantsNavyDark);
          ctx.fillStyle = gBot;
          roundRect(ctx, x, bottomY, w, bottomH, Math.max(3, bodyR - 2));
          ctx.fill();
          // 胸部イエローライン（アクセント）
          ctx.fillStyle = palette.suitYellow;
          ctx.fillRect(x + 4, bodyY + 6, w - 8, 3);
          // 下端アクセントは削除（配色をシンプルに）

          // 胸のGエンブレム（黄）
          ctx.fillStyle = palette.suitYellow;
          ctx.font = 'bold 11px system-ui, sans-serif';
          ctx.textAlign = 'center';
          ctx.textBaseline = 'middle';
          ctx.fillText('G', cx, bodyY + bodyH * 0.55);

          // 手足（簡易）：ポーズ変化
          const isAir = anim.air > 0.1;
          const goingUp = isAir && player.vy < -60;
          const goingDown = isAir && player.vy > 120;
          const armY = bodyY + 6;
          const legY = bodyY + bodyH - 2;
          const limbW = 3;
          const limbLen = 8;
          // 腕（上半身の色：緑）
          ctx.fillStyle = palette.shirtGreenDark;
          if (goingUp) {
            // 両腕を上げる
            ctx.fillRect(x - 2, armY - 8, limbW, limbLen + 6);
            ctx.fillRect(x + w - limbW + 2, armY - 8, limbW, limbLen + 6);
          } else if (goingDown) {
            // 両腕をやや後ろに（下へ）
            ctx.fillRect(x - 2, armY + 2, limbW, limbLen);
            ctx.fillRect(x + w - limbW + 2, armY + 2, limbW, limbLen);
          } else {
            // ニュートラル（少し外）
            ctx.fillRect(x - 2, armY, limbW, limbLen);
            ctx.fillRect(x + w - limbW + 2, armY, limbW, limbLen);
          }
          // 脚（下半身の色：紺）＋ 足は丸
          ctx.fillStyle = palette.pantsNavy;
          let legLenL = limbLen, legLenR = limbLen;
          let legYOffset = -1;
          if (goingUp) { legYOffset = -4; legLenL = limbLen - 2; legLenR = limbLen - 2; }
          else if (goingDown) { legYOffset = 0; legLenL = limbLen + 2; legLenR = limbLen + 2; }
          // 細い脚
          ctx.fillRect(cx - 6, legY + legYOffset, limbW, legLenL);
          ctx.fillRect(cx + 3, legY + legYOffset, limbW, legLenR);
          // 丸い足先
          const footR = 4.5;
          const fx1 = cx - 6 + limbW/2;
          const fx2 = cx + 3 + limbW/2;
          const fy = legY + legYOffset + Math.max(legLenL, legLenR) + 2 + (goingDown ? 2 : (goingUp ? -1 : 0));
          ctx.beginPath(); ctx.arc(fx1, fy, footR, 0, Math.PI*2); ctx.fill();
          ctx.beginPath(); ctx.arc(fx2, fy, footR, 0, Math.PI*2); ctx.fill();

          // オーラ（軽さの表現）
          const aura = ctx.createRadialGradient(cx, cy, 4, cx, cy, hr * 1.2);
          aura.addColorStop(0, 'rgba(155,89,182,0.20)');
          aura.addColorStop(1, 'rgba(155,89,182,0)');
          ctx.fillStyle = aura;
          ctx.beginPath(); ctx.arc(cx, cy, hr * 1.2, 0, Math.PI * 2); ctx.fill();

          // フィーバー中の強化演出（発光・アウトライン）
          if (state.fever) {
            const t = state.time;
            const pulse = 0.6 + 0.4 * Math.sin(t * 10);
            // 追加オーラ（大きめ）
            const aura2 = ctx.createRadialGradient(cx, cy, 6, cx, cy, hr * 1.8);
            aura2.addColorStop(0, `rgba(255,230,120,${0.35 + 0.2*pulse})`);
            aura2.addColorStop(1, 'rgba(255,230,120,0)');
            ctx.fillStyle = aura2;
            ctx.beginPath(); ctx.arc(cx, cy, hr * 1.8, 0, Math.PI * 2); ctx.fill();

            // 頭部のゴールド縁取り
            ctx.strokeStyle = `rgba(255,220,120,${0.8})`;
            ctx.lineWidth = 2 + pulse;
            ctx.beginPath(); ctx.arc(cx, cy, hr + 2, 0, Math.PI * 2); ctx.stroke();

            // 胴体のゴールド縁取り
            const bodyY = y + 2 * hr;
            const bodyH = Math.max(14, h - 2 * hr);
            const bodyR = 7;
            ctx.lineWidth = 2;
            roundRect(ctx, x - 1, bodyY - 1, w + 2, bodyH + 2, bodyR + 2);
            ctx.stroke();
          }

          ctx.restore();
        }

        function drawShadow(x, y, w, h, anim) {
          ctx.save();
          const cx = x + w / 2;
          const sy = y + h + 8;
          const air = anim ? anim.air : 0;
          const alpha = 0.25 * (1 - 0.6 * air);
          const scale = 0.85; // 影スプライトを0.85倍
          const rx = Math.max(8, w * (0.7 - 0.25 * air) * scale);
          const ry = 5 * (1 - 0.4 * air) * scale;
          ctx.fillStyle = `rgba(0,0,0,${alpha.toFixed(3)})`;
          ctx.beginPath();
          ctx.ellipse(cx, sy, rx, Math.max(2, ry), 0, 0, Math.PI * 2);
          ctx.fill();
          ctx.restore();
        }

        function roundRect(ctx, x, y, w, h, r) {
          const rr = Math.min(r, w/2, h/2);
          ctx.beginPath();
          ctx.moveTo(x + rr, y);
          ctx.arcTo(x + w, y, x + w, y + h, rr);
          ctx.arcTo(x + w, y + h, x, y + h, rr);
          ctx.arcTo(x, y + h, x, y, rr);
          ctx.arcTo(x, y, x + w, y, rr);
          ctx.closePath();
        }

        // Show intro overlay on load + ベスト表示の反映
        overlay.style.display = 'flex';
        try {
          const bestLine = document.getElementById('bestLine');
          if (bestLine) bestLine.textContent = `最高記録: ${state.best} m`;
        } catch (_) {}
      })();
    </script>
    <!-- Optional external phase controller: disabled to avoid 404
    <script src="scripts/phase-control.js"></script>
    -->
    <!-- 開発用ツール: ?dev=1 で有効化 -->
    <script src="scripts/dev-tools.js"></script>
    <script>
      // 予備ローダ: dev-toolsの404時にフォールバック読込
      (function(){
        try {
          const sp = new URL(location.href).searchParams;
          const devParam = (sp.get('dev')||'').trim();
          const devOn = devParam === '1' || devParam === '2';
          if (!devOn) return;
          setTimeout(function(){
            if (window.__DEV_TOOLS_LOADED) return;
            console.warn('[DEV-TOOLS] static include missing or 404, loading dynamically...');
            const s = document.createElement('script');
            s.src = 'scripts/dev-tools.js';
            s.async = true;
            s.onerror = function(){
              console.warn('[DEV-TOOLS] scripts/dev-tools.js 404, fallback to scripts/dev-tools-simple.js');
              const s2 = document.createElement('script');
              s2.src = 'scripts/dev-tools-simple.js';
              s2.async = true;
              document.body.appendChild(s2);
            };
            document.body.appendChild(s);
          }, 80);
        } catch(_) {}
      })();
    </script>
  </body>
</html>
